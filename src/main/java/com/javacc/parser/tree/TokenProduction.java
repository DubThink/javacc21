/* Generated by: JavaCC 21 Parser Generator. Do not edit. TokenProduction.java */
package com.javacc.parser.tree;

import java.util.*;

import com.javacc.parser.*;
@SuppressWarnings("unused")
public class TokenProduction extends BaseNode {
    /**
     * This is true if this corresponds to a production that actually appears in
     * the input grammar. Otherwise (if this is created to describe a regular
     * expression that is part of the BNF) this is set to false.
     */
    private boolean explicit=true;
    public boolean getIgnoreCase() {
        for (Node n : children) {
            if (n instanceof Token) {
                Token t=(Token) n;
                if (t.getId()==JavaCCConstants._IGNORE_CASE) {
                    return true;
                }
            }
        }
        return false;
    }

    private String lexicalState;
    public void setLexicalState(String lexicalState) {
        this.lexicalState=lexicalState;
    }

    public List<RegexpSpec>getRegexpSpecs() {
        return childrenOfType(RegexpSpec.class);
    }

    /**
     * The states in which this regular expression production exists.
     */
    public String[] getLexStates() {
        if (lexicalState!=null) {
            return new String[]{lexicalState};
        }
        if (!explicit) {
            return new String[]{getGrammar().getDefaultLexicalState()};
        }
        if (isInAllLexStates()) {
            return getGrammar().getLexicalStates();
        }
        Set<String>states=new LinkedHashSet<String>();
        for (Node n : children) {
            if (n instanceof Token) {
                Token t=(Token) n;
                if (t.getId()==JavaCCConstants.IDENTIFIER) {
                    states.add(n.toString());
                }
            }
        }
        if (states.isEmpty()) {
            return new String[]{getGrammar().getDefaultLexicalState()};
        }
        String[] lexStates=new String[states.size()];
        int i=0;
        for (String s : states) {
            lexStates[i++]=s;
        }
        return lexStates;
    }

    private boolean isInAllLexStates() {
        for (Node n : children) {
            if (n instanceof Token) {
                Token t=(Token) n;
                if (t.getId()==JavaCCConstants.STAR) {
                    return true;
                }
            }
        }
        return false;
    }

    public void setExplicit(boolean explicit) {
        this.explicit=explicit;
    }

    public boolean isExplicit() {
        return explicit;
    }

    public boolean getExplicit() {
        return explicit;
    }

    public String getKind() {
        for (Token t : childrenOfType(Token.class)) {
            switch(t.getId()) {
                case JavaCCConstants._MORE:
                return"MORE";
                case JavaCCConstants._SPECIAL_TOKEN:
                return"SPECIAL_TOKEN";
                case JavaCCConstants._SKIP:
                return"SKIP";
                case JavaCCConstants._TOKEN:
                return"TOKEN";
            }
        }
        return"TOKEN";
    }

}
