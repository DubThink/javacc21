/* Generated by: JavaCC 21 Parser Generator. Do not edit. BNFProduction.java */
package com.javacc.parser.tree;

import java.util.*;

import com.javacc.lexgen.TokenSet;
import com.javacc.parsegen.Expansion;
import com.javacc.parser.*;
@SuppressWarnings("unused")
public class BNFProduction extends BaseNode {
    public CodeBlock getJavaCode() {
        return firstChildOfType(CodeBlock.class);
    }

    public TreeBuildingAnnotation getTreeBuildingAnnotation() {
        return firstChildOfType(TreeBuildingAnnotation.class);
    }

    public String getNodeName() {
        TreeBuildingAnnotation tba=getTreeBuildingAnnotation();
        if (tba!=null) {
            String nodeName=tba.getNodeName();
            if (nodeName==null) {
                return nodeName;
            }
        }
        return this.getName();
    }

    private boolean forced;
    public void setForced(boolean forced) {
        this.forced=forced;
    }

    public boolean getForced() {
        return forced;
    }

    private String leadingComments;
    private Expansion expansion;
    public void setName(String name) {
        this.name=name;
    }

    public String getName() {
        return name;
    }

    public ThrowsList getThrowsList() {
        return firstChildOfType(ThrowsList.class);
    }

    public FormalParams getParameterList() {
        return firstChildOfType(FormalParams.class);
    }

    public TreeBuildingAnnotation getTreeNodeBehavior() {
        return firstChildOfType(TreeBuildingAnnotation.class);
    }

    /**
     * The NonTerminal nodes which refer to this production.
     */
    private List<NonTerminal>referringNonTerminals;
    public List<NonTerminal>getReferringNonTerminals() {
        if (referringNonTerminals==null) {
            referringNonTerminals=new ArrayList<NonTerminal>();
            for (NonTerminal nt : getGrammar().descendantsOfType(NonTerminal.class)) {
                if (nt.getName().equals(name)) {
                    referringNonTerminals.add(nt);
                }
            }
        }
        return referringNonTerminals;
    }

    /**
     * The name of the non-terminal of this production.
     */
    private String name;
    public Expansion getExpansion() {
        return expansion;
    }

    public void setExpansion(Expansion expansion) {
        this.expansion=expansion;
    }

    /**
     * Can this production be matched by an empty string?
     */
    public boolean isPossiblyEmpty() {
        return getExpansion().isPossiblyEmpty();
    }

    /**
     * A list of all non-terminals that this one can expand to without having to
     * consume any tokens. Also an index that shows how many pointers exist.
     */
    public BNFProduction[] leftExpansions=new BNFProduction[10];
    public int leIndex=0;
    /**
     * The following variable is used to maintain state information for the
     * left-recursion determination algorithm: It is initialized to 0, and set
     * to -1 if this node has been visited in a pre-order walk, and then it is
     * set to 1 if the pre-order walk of the whole graph from this node has been
     * traversed. i.e., -1 indicates partially processed, and 1 indicates fully
     * processed.
     */
    public int walkStatus=0;
    protected StringBuilder dumpPrefix(int indent) {
        StringBuilder sb=new StringBuilder(128);
        for (int i=0; i<indent; i++) sb.append("  ");
        return sb;
    }

    protected String getSimpleName() {
        String name=getClass().getName();
        return name.substring(name.lastIndexOf(".")+1);
        // strip the package
        // name
    }

    public String getAccessModifier() {
        for (Token t : childrenOfType(Token.class)) {
            if (t.getId()==JavaCCConstants.PRIVATE) {
                return"private";
            }
            else if (t.getId()==JavaCCConstants.PROTECTED) {
                return"protected";
            }
            else if (t.getId()==JavaCCConstants.PUBLIC) {
                return"public";
            }
        }
        return"";
    }

    public ReturnType getReturnType() {
        return firstChildOfType(ReturnType.class);
    }

    public void adjustFirstToken(Token t) {
        this.leadingComments=t.getLeadingComments();
        t.clearSpecialToken();
    }

    public String getLeadingComments() {
        return leadingComments;
    }

    private TokenSet firstSet,finalSet;
    public TokenSet getFirstSet() {
        if (firstSet==null) {
            firstSet=getExpansion().getFirstSet();
        }
        return firstSet;
    }

    public TokenSet getFinalSet() {
        if (finalSet==null) {
            finalSet=getExpansion().getFinalSet();
        }
        return finalSet;
    }

}
