/* Generated by: JavaCC 21 Parser Generator. Do not edit. NonTerminal.java */
package com.javacc.parser.tree;

import com.javacc.lexgen.TokenSet;
import com.javacc.parsegen.*;
import com.javacc.parser.*;
@SuppressWarnings("unused")
public class NonTerminal extends Expansion {
    /**
     * The production this non-terminal corresponds to.
     */
    public BNFProduction getProduction() {
        return getGrammar().getProductionByName(getName());
    }

    public InvocationArgs getArgs() {
        return firstChildOfType(InvocationArgs.class);
    }

    public Expression getLHS() {
        return firstChildOfType(Expression.class);
    }

    public String getName() {
        for (Node n : children) {
            if (n instanceof Token) {
                Token t=(Token) n;
                if (t.getId()==JavaCCConstants.IDENTIFIER) {
                    return n.toString();
                }
            }
        }
        return null;
    }

    public TokenSet getFirstSet() {
        if (firstSet==null) {
            firstSet=getProduction().getExpansion().getFirstSet();
        }
        return firstSet;
    }

    public TokenSet getFinalSet() {
        if (finalSet==null) {
            finalSet=getProduction().getExpansion().getFinalSet();
        }
        return finalSet;
    }

    public boolean isPossiblyEmpty() {
        return getProduction().isPossiblyEmpty();
    }

    public boolean requiresPhase2Routine() {
        return getProduction().getExpansion().requiresPhase2Routine();
    }

    // REVISIT. Why is this necessary?
    private boolean inMinimumSize;
    public int minimumSize(int oldMin) {
        if (inMinimumSize) {
            return Integer.MAX_VALUE;
        }
        int retval=Integer.MAX_VALUE;
        inMinimumSize=true;
        BNFProduction prod=getProduction();
        if (prod instanceof BNFProduction) {
            retval=prod.getExpansion().getMinimumSize();
        }
        inMinimumSize=false;
        return retval;
    }

}
