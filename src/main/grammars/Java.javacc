/* Copyright (c) 2008-2021 Jonathan Revusky, revusky@javacc.com
 * Copyright (c) 2006, Sun Microsystems Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notices,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name Jonathan Revusky, Sun Microsystems, Inc.
 *       nor the names of any contributors may be used to endorse or promote
 *       products derived from this software without specific prior written
 *       permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

JAVA_UNICODE_ESCAPE;
PARSER_PACKAGE="org.parsers.java";
NODE_PACKAGE="org.parsers.java.ast";
DEFAULT_LEXICAL_STATE=JAVA;
PRESERVE_LINE_ENDINGS=false;
TABS_TO_SPACES=8;

INCLUDE("JavaLexer.javacc")

INJECT PARSER_CLASS : {

  private Token TOKEN_HOOK(Token tok) {
    String img = tok.getImage();
    if (img==null || !img.startsWith(">")) return tok;
    boolean inGenericTypeSpec = isInProduction("TypeArguments", "TypeParameters");
    if (inGenericTypeSpec && (img.equals(">>") || img.equals(">>>"))) {
        // If we've entered the TypeParameters or TypeArguments production, we need to split
        // a ">>" or ">>>" into 2 (or 3) GT tokens.
        Token gt = Token.split(tok, 1, GT, GT);
        if (img.length() == 3) {
          Token next = Token.split(gt.getNext(), 1, GT, GT);
        }
        return gt;
    }
    else if (!inGenericTypeSpec && img.length() ==1) {
      // In this case we do the reverse. We merge 2 (or 3) GT tokens into a right shift operator
      Token next = tok.getNextToken();
      if (next != null && next.getType() == GT) {
        Token nextNext = next.getNextToken();
        Token merged = Token.merge(tok, next, RSIGNEDSHIFT);
        if (nextNext != null && nextNext.getType() == GT) {
            merged = Token.merge(merged, nextNext, RUNSIGNEDSHIFT);
        } 
        return merged;
      }
    }
    return tok;
  }
}

CompilationUnit CompilationUnit #CompilationUnit :
  [ PackageDeclaration ]
  ( ImportDeclaration )*
  (
     ( TypeDeclaration | ";")+
     |
     <EOF>
  )
  {
    return CURRENT_NODE;
  }
;

INJECT IntegerLiteral :
{
   public int getValue() {
     return Integer.valueOf(getImage());
   }
}


PackageDeclaration : (Annotation)* "package" =>|| Name ";" ;

INJECT PackageDeclaration :
{
  public String getPackageName() {
    Node nameNode = getChild(getChildCount()-2);
    return nameNode.toString();
  }
}

ImportDeclaration : "import" [ "static" ] Name [ "." "*" ] ";" ;

Modifiers #void :
{EnumSet<TokenType> modifiers = EnumSet.noneOf(TokenType.class);}
   (
     SCAN 2=>
     (
      SCAN {!modifiers.contains(STATIC)}
      => <STATIC> {modifiers.add(STATIC);}
      |
      SCAN {!modifiers.contains(ABSTRACT)}
      => <ABSTRACT> {modifiers.add(ABSTRACT);}
      |
      SCAN {!modifiers.contains(FINAL)}
      => <FINAL> {modifiers.add(FINAL);}
      |
      SCAN {!modifiers.contains(SYNCHRONIZED)}
      => <SYNCHRONIZED> {modifiers.add(SYNCHRONIZED);}
      |
      SCAN {!modifiers.contains(NATIVE)}
      => <NATIVE> {modifiers.add(NATIVE);}
      |
      SCAN {!modifiers.contains(PUBLIC) && !modifiers.contains(PRIVATE) && !modifiers.contains(PROTECTED)}
      => <PUBLIC> {modifiers.add(PUBLIC);}
      |
      SCAN {!modifiers.contains(PUBLIC) && !modifiers.contains(PRIVATE) && !modifiers.contains(PROTECTED)}
      => <PROTECTED> {modifiers.add(PROTECTED);}
      |
      SCAN {!modifiers.contains(PUBLIC) && !modifiers.contains(PRIVATE) && !modifiers.contains(PROTECTED)}
      => <PRIVATE> {modifiers.add(PRIVATE);}
      |
      SCAN {!modifiers.contains(TRANSIENT)}
      => <TRANSIENT> {modifiers.add(TRANSIENT);}
      |
      SCAN {!modifiers.contains(VOLATILE)}
      => <VOLATILE> {modifiers.add(VOLATILE);}
      | 
      SCAN {!modifiers.contains(STRICTFP)}
      => <STRICTFP> {modifiers.add(STRICTFP);}
      |
//      SCAN {!modifiers.contains(_DEFAULT)} \MethodDeclaration
//      => <_DEFAULT> {modifiers.add(_DEFAULT);}
//        |
      Annotation
     )
   )*
;

Modifiers2 #void :
 (
   "public"
  |
   "static" 
  |
   "protected"
  |
   "private" 
  |
   "final" 
  |
   "abstract" 
  |
   "synchronized"
  |
   "native" 
  |
   "transient" 
  |
  SCAN ~\MethodDeclaration =>
   "volatile" 
  |
   "strictfp" 
  |
  SCAN \MethodDeclaration =>
   "default"
  |
  Annotation
 )*
;

/*
 * Declaration syntax follows.
 */

TypeDeclaration TypeDeclaration #TypeDeclaration(false) :
 (      
  AnnotationTypeDeclaration
  |
  ClassDeclaration
  |
  InterfaceDeclaration
  |
  EnumDeclaration
 )
 {
        return (TypeDeclaration) peekNode();
 }
;

INJECT AnnotationTypeDeclaration : extends TypeDeclaration;
INJECT ClassDeclaration : extends TypeDeclaration;
INJECT InterfaceDeclaration : extends TypeDeclaration;
INJECT EnumDeclaration : extends TypeDeclaration;

ClassDeclaration :
  Modifiers
  "class" =>||
  <IDENTIFIER>
  [ TypeParameters ]
  [ ExtendsList]
  [ ImplementsList ]
  ClassOrInterfaceBody
;

InterfaceDeclaration :
  Modifiers
  "interface" =>||
  <IDENTIFIER> 
  [ TypeParameters ]
  [ ExtendsList ] 
  ClassOrInterfaceBody
;

ExtendsList : 
   "extends" ClassOrInterfaceType
   ( 
     SCAN \InterfaceDeclaration => 
     "," ClassOrInterfaceType 
   )*
;

INJECT ExtendsList :
import java.util.List; 
{
    public List<ObjectType> getTypes() {
        return childrenOfType(ObjectType.class);
    }
}

ImplementsList :
   "implements" ClassOrInterfaceType
   ( 
     "," ClassOrInterfaceType 
   )*
;


EnumDeclaration :
   Modifiers
   "enum" =>|| <IDENTIFIER>
   [ImplementsList] 
   EnumBody
;

EnumBody :
   "{"
   [ EnumConstant ( "," =>|+1 EnumConstant )* ]
   [ "," ]
   [ ";" ( ClassOrInterfaceBodyDeclaration )* ]
   "}"
;

EnumConstant:
  Modifiers <IDENTIFIER> [ Arguments ] [ ClassOrInterfaceBody ]
;

TypeParameters #TypeParameterList :
   "<"
   TypeParameter ( "," TypeParameter )* 
   ">"
;

INJECT TypeParameterList : 
  import java.util.List;
{
    public List<TypeParameter> getParameters() {
        return childrenOfType(TypeParameter.class);
    }
}

TypeParameter: <IDENTIFIER> [TypeBound];

TypeBound :
   "extends" ClassOrInterfaceType ( "&" ClassOrInterfaceType )*
;

ClassOrInterfaceBody :
    "{"
    ( 
       ClassOrInterfaceBodyDeclaration 
    )*
    "}"
;


INJECT ClassOrInterfaceBodyDeclaration : 
import static PARSER_PACKAGE.CONSTANTS_CLASS.TokenType.*;
{
    public boolean isPrivate() {
        return firstDescendantOfType(PRIVATE) != null;
    }
    
    public boolean isStatic() {
        return firstDescendantOfType(STATIC) != null;
    }
    
    public boolean isProtected() {
        return firstDescendantOfType(PROTECTED) != null;
    }
    
    public boolean isPublic() {
        return firstDescendantOfType(PUBLIC) != null;
    }
}

ClassOrInterfaceBodyDeclaration #ClassOrInterfaceBodyDeclaration :
  ";"
  |
  Initializer
  |
  AnnotationTypeDeclaration
  |
  InterfaceDeclaration
  |
  EnumDeclaration
  |
  ClassDeclaration
  |
  ConstructorDeclaration
  |
  FieldDeclaration
  |
  MethodDeclaration
;

FieldDeclaration :
  Modifiers 
  Type VariableDeclarator =>|+1 ( "," VariableDeclarator )* ";"
;

VariableDeclarator :
  VariableDeclaratorId [ "=" VariableInitializer ]
;

VariableDeclaratorId #VariableDeclaratorId :
  <IDENTIFIER> ( "[" "]" )*
;

VariableInitializer : ArrayInitializer | Expression ;

ArrayInitializer :
  "{" [ VariableInitializer ( "," =>|+1 VariableInitializer )* ] [ "," ] "}"
;


MethodDeclaration MethodDeclaration :
  Modifiers2
  [ TypeParameters ]
  ReturnType
  =>|+2
  MethodDeclarator 
  [ ThrowsList ]
  ( Block | ";" )
  {return CURRENT_NODE;}
;


MethodDeclarator #void :
  <IDENTIFIER> FormalParameters ( "[" "]" )*
;

FormalParameters #FormalParams :
   "("
    [ FormalParameter ( "," FormalParameter )* ]
   ")"
;


FormalParameter : Modifiers Type [ "..." ] VariableDeclaratorId ;

INJECT ConstructorDeclaration : extends ClassOrInterfaceBodyDeclaration

ConstructorDeclaration :
  Modifiers
  [ TypeParameters ]
  <IDENTIFIER> FormalParameters =>||
  [ ThrowsList ]
  "{"
  [ => ExplicitConstructorInvocation ]
  ( BlockStatement )*
  "}"
;

ExplicitConstructorInvocation :
  [TypeArguments] ("this" | "super") =>|+1 Arguments ";"
  |
  [=>Name "."] [TypeArguments] "super" =>|+1 Arguments ";"
;

Initializer :
  [ "static" ] =>|+1 Block
;


/*
 * Type, name and expression syntax follows.
 */

Type :
   => ReferenceType
   |
   PrimitiveType
;

INJECT ReferenceType : extends Type;
INJECT PrimitiveArrayType : extends Type;
INJECT PrimitiveType : extends Type;

ReferenceType : 
   PrimitiveArrayType
   |
   ClassOrInterfaceType (=> "[" "]" )*
;

ClassOrInterfaceType #ObjectType :
    <IDENTIFIER>
    [ TypeArguments ]
    ( "." <IDENTIFIER> =>|| [ TypeArguments ] )*
;

INJECT ObjectType : extends Type 
{
    public boolean equals(Object obj) {
        if (obj instanceof ObjectType) {
            return ((ObjectType) obj).toString().equals(this.toString());
        }
        return false;
    }
    
    public String toString() {
        StringBuilder buf = new StringBuilder();
        for (Token t : getRealTokens()) {
            buf.append(t);
        }
        return buf.toString();
    }
}

DiamondOperator :  "<" ">" =>|| ;

PossiblyEmptyTypeArguments #void :
   DiamondOperator
   |
   TypeArguments
;

TypeArguments :
   "<" =>|+1
   TypeArgument ( "," TypeArgument )* 
   ">"
;

TypeArgument :
   (Annotation)*
   (
      ReferenceType
      |
      "?" [ WildcardBounds ]
   )
;

WildcardBounds :
   ("extends" | "super") ReferenceType
;


PrimitiveType #PrimitiveType :
  "boolean"
   |
  "char"
   |
  "byte"
   |
  "short"
   |
  "int"
   |
  "long"
   |
  "float"
   |
  "double"
;

PrimitiveArrayType : 
    PrimitiveType (=> "[" "]")+
;

ReturnType #ReturnType : "void" | Type ;

Name : <IDENTIFIER> ( => "." <IDENTIFIER>)* ;

ThrowsList : "throws" Name ( "," Name )* ;

Expression Expression #Expression(>1) :
    AssignmentExpression
    {return (Expression) peekNode();}
;

INJECT AssignmentExpression : extends Expression
INJECT TernaryExpression : extends Expression 
INJECT ConditionalOrExpression : extends Expression 
INJECT ConditionalAndExpression : extends Expression 
INJECT InclusiveOrExpression : extends Expression 
INJECT InclusiveAndExpression : extends Expression 
INJECT ExclusiveOrExpression : extends Expression 
INJECT AndExpression : extends Expression 
INJECT EqualityExpression : extends Expression 
INJECT InstanceOfExpression : extends Expression 
INJECT RelationalExpression : extends Expression 
INJECT ShiftExpression : extends Expression
INJECT AdditiveExpression : extends Expression
INJECT MultiplicativeExpression : extends Expression
INJECT UnaryExpression : extends Expression
INJECT PreIncrementExpression : extends Expression
INJECT PreDecrementExpression : extends Expression
INJECT UnaryExpressionNotPlusMinus : extends Expression
INJECT PostfixExpression : extends Expression
INJECT CastExpression : extends Expression
INJECT PrimaryExpression : extends Expression 
INJECT LambdaExpression : extends Expression 
INJECT CodeBlock : extends Expression
INJECT SwitchExpression : extends Expression

AssignmentExpression :
  TernaryExpression
  [ 
      SCAN {peekNode() instanceof PrimaryExpression} =>
        AssignmentOperator =>|+1 Expression
  ]
;

AssignmentOperator #void :
{
  "=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | ">>>=" | "&=" | "^=" | "|="
}

TernaryExpression :
  ConditionalOrExpression [  "?" Expression ":" Expression ]
;

ConditionalOrExpression :
  ConditionalAndExpression ( "||" ConditionalAndExpression )*
;

ConditionalAndExpression :
  InclusiveOrExpression ( "&&" InclusiveOrExpression )*
;

InclusiveOrExpression :
  ExclusiveOrExpression ( "|" ExclusiveOrExpression )*
;

ExclusiveOrExpression :
  AndExpression ( "^" AndExpression )*
;

AndExpression :
  EqualityExpression ( "&" EqualityExpression )*
;

EqualityExpression :
  InstanceOfExpression ( ( "==" | "!=" ) InstanceOfExpression )*
;

InstanceOfExpression :
  RelationalExpression [ "instanceof" Type ]
;

RelationalExpression :
  ShiftExpression 
  (
    ( 
     "<" 
     | ">" 
     | "<=" 
     | ">=" 
    ) 
    ShiftExpression
  )*
;


ShiftExpression :
   AdditiveExpression
   (
      ("<<" | ">>" | ">>>")
      AdditiveExpression
   )*
;

AdditiveExpression :
  MultiplicativeExpression (  ( "+" | "-" ) MultiplicativeExpression )*
;

MultiplicativeExpression :
  UnaryExpression (  ( "*" | "/" | "%" ) UnaryExpression )*
;

UnaryExpression :
  ( "+" | "-" ) UnaryExpression
|
  PreIncrementExpression
|
  PreDecrementExpression
|
  UnaryExpressionNotPlusMinus
;

PreIncrementExpression :
  "++" PrimaryExpression
;

PreDecrementExpression :
  "--" PrimaryExpression
;

UnaryExpressionNotPlusMinus :
  ( "~" | "!" ) UnaryExpression
  |
  SCAN ~\...\NewSwitchLabel LambdaLHS
  => LambdaExpression 
  |
  => CastExpression
  |
  PostfixExpression
  |
  SwitchExpression
;

PostfixExpression :
  PrimaryExpression [ "++" | "--" ]
;

SwitchExpression #SwitchExpression :
   SwitchStatement
;

CastExpression : 
  "(" PrimitiveType ")" =>|| UnaryExpression
  |
  => "(" ReferenceType ")" UnaryExpressionNotPlusMinus
  |
  => "(" ClassOrInterfaceType ("&" ClassOrInterfaceType)+ ")" UnaryExpressionNotPlusMinus 
;

PrimaryExpression PrimaryExpression #PrimaryExpression :
    PrimaryPrefix 
    ( SCAN 2 PrimarySuffix )*
    {
       return CURRENT_NODE;
    }
;

MemberSelector :
  "." =>|+2 TypeArguments <IDENTIFIER>
;

PrimaryPrefix :
  Literal
 |
  "this"
 |
 => "super" "." [TypeArguments] <IDENTIFIER>
 |
  "(" Expression ")"
 |
  AllocationExpression
 |
 => PrimitiveType "." "class"
 |
 => ReturnType "." "class"
 |
 => MethodReference
 |  
 Name
;

MethodReference :
    (Type | "super")
     "::" 
     (<IDENTIFIER>|"new")
;

PrimarySuffix :
 (
  => "." ("this"|"super")
  |
  "." =>|+1 AllocationExpression
    |
  MemberSelector
  |
  "[" [Expression] "]"
  |
  "." <IDENTIFIER>
  |
  "::" (<IDENTIFIER>|"new")
  |
  Arguments
 )
;

Literal #void :
  <INTEGER_LITERAL>
  |
  <LONG_LITERAL>
  |
  <FLOATING_POINT_LITERAL>
  |
  <CHARACTER_LITERAL>
  |
  <STRING_LITERAL>
  |
  <TEXT_BLOCK_LITERAL>
  |
  "true"
  |
  "false"
  |
  "null"
;

Arguments #InvocationArgs :
    "("
    [ Expression ("," Expression)* ]
    ")"
;


AllocationExpression :
  "new" PrimitiveType =>|| ArrayDimsAndInits
  |
  "new" ClassOrInterfaceType [ PossiblyEmptyTypeArguments ]
    (
      SCAN 2 ArrayDimsAndInits
      |
      Arguments [ ClassOrInterfaceBody ]
    )
;

ArrayDimsAndInits :
  SCAN 2
  ( 
    "[" =>|+1 Expression "]" 
  )+ 
  ( 
    => "[" "]" 
  )*
  |
  ( 
    "[" "]" 
  )+ 
  ArrayInitializer
;

Label : <IDENTIFIER><COLON> =>|| ;

/*
 * Statement syntax follows.
 */

Statement  :
  (Label)*
  UnlabeledStatement
;


UnlabeledStatement #void :
  AssertStatement
  |
  Block
  |
  YieldStatement
  |
  EmptyStatement
  |
  StatementExpression ";"
  |
  SwitchStatement
  |
  IfStatement
  |
  WhileStatement
  |
  DoStatement
  |
  ForStatement
  |
  BreakStatement
  |
  ContinueStatement
  |
  ReturnStatement
  |
  ThrowStatement
  |
  SynchronizedStatement
  |
  TryStatement
;

TryStatement #void :
   TryWithResources
   |
   ClassicTryStatement
   |
   "try" FAIL "Expecting '{' or '(' after 'try'"
;

AssertStatement :
  "assert" Expression [ ":" Expression ] ";"
;

CodeBlock Block #CodeBlock :
  "{"
  (BlockStatement)*
  "}" 
   {
       return CURRENT_NODE;
   }
;

BlockStatement :
  LocalVariableDeclaration ";"
  |
  ClassDeclaration
  |
  InterfaceDeclaration
  |
  Statement
;

LocalVariableDeclaration :
  Modifiers Type =>|+1 VariableDeclarator ( "," VariableDeclarator )*
;

EmptyStatement : ";" ;

StatementExpression :
/*
 * The last expansion of this production accepts more than the legal
 * Java expansions for StatementExpression.  This expansion does not
 * use PostfixExpression for performance reasons.
 */
  PreIncrementExpression
 |
  PreDecrementExpression
  |
  PrimaryExpression
  [
    "++"
  |
    "--"
  |
    AssignmentOperator Expression
  ]
;

SwitchStatement :
  SCAN "switch" "(" Expression ")" "{" NewSwitchLabel
  => NewSwitchStatement
  |
  ClassicSwitchStatement
;

ClassicSwitchStatement : 
  "switch" "(" Expression ")" "{"
  (ClassicCaseStatement)*
  "}"    
;

ClassicSwitchLabel :
  (
   "case" Expression ("," Expression)* 
   |
   "default" 
  )
  ":"
;

ClassicCaseStatement :
  ClassicSwitchLabel
  (BlockStatement)*
;

NewSwitchStatement :
  "switch" "(" Expression ")" "{"
  (NewCaseStatement)*
  "}"
;

NewSwitchLabel :
  (
   "case" Expression ("," Expression)* 
   |
   "default" 
  )
  "->"
;

NewCaseStatement : 
   NewSwitchLabel 
   (
     Block
     |
     ThrowStatement
     |
     SCAN \...\SwitchExpression
     => Expression ";"
     |
     SCAN ~\...\SwitchExpression
     => BlockStatement
   )
;

IfStatement :
  "if" "(" Expression ")" Statement [ "else" Statement ]
;

WhileStatement :
  "while" "(" Expression ")" Statement
;

DoStatement :
  "do" Statement "while" "(" Expression ")" ";"
;

ForStatement :
  "for" "("
  (
      Modifiers Type <IDENTIFIER> ":" =>|| Expression 
      |
      [ ForInit ] ";" [ Expression ] ";" [ StatementExpressionList ]
  )
  ")" Statement
;

ForInit :
  //SCAN Modifiers Type <IDENTIFIER> =>
  LocalVariableDeclaration
  |
  StatementExpressionList
;

StatementExpressionList :
  StatementExpression ( "," StatementExpression )*
;

BreakStatement :
  "break" [ <IDENTIFIER> ] ";"
;

YieldStatement :
   <IDENTIFIER>
   [
     SCAN {!getToken(0).getImage().equals("yield")}#
     => FAIL "supposed to have \"yield\" here"
     |
     SCAN ~\...\SwitchExpression
     => FAIL "need to be in a switch expression"
   ]
   Expression
   ";" 
   =>||
;

ContinueStatement :
  "continue" [ <IDENTIFIER> ] ";"
;

ReturnStatement :
  "return"
  [
    Expression
  ]
  ";"
;

ThrowStatement :
 "throw" 
  Expression
 ";"
;

SynchronizedStatement :
  "synchronized" "(" Expression ")" Block
;

ClassicTryStatement :
  "try"
  =>|+1
  Block 
  (
     FinallyBlock
     |
     (
        (CatchBlock)+ 
        [FinallyBlock]
     )
  )
;

TryWithResources :
   "try" "(" 
   =>||
     (
         => LocalVariableDeclaration
         |
         Name
      )
      (
        ";"
       [
          => LocalVariableDeclaration
          |
          Name
       ]
     )*
    ")"
    Block
    (CatchBlock)*
    [FinallyBlock]
;

CatchBlock :
    "catch"
    "("
    ["final"]
    ClassOrInterfaceType ("|" ClassOrInterfaceType)* VariableDeclaratorId
    ")"
    Block 
;

INJECT CatchBlock :
{
    public CodeBlock getBlock() {
        return firstChildOfType(CodeBlock.class);
    }
}

FinallyBlock : "finally" Block;

INJECT FinallyBlock :
{
    public CodeBlock getBlock() {
        return firstChildOfType(CodeBlock.class);
    }
}


/* Annotation syntax follows. */

Annotation #Annotation :
 ( 
   NormalAnnotation
   |
   SingleMemberAnnotation
   |
   MarkerAnnotation
 )
;

NormalAnnotation #void :
   "@" Name "(" =>|+2 [ MemberValuePairs ] ")"
;

MarkerAnnotation #void :
  "@" Name
;

SingleMemberAnnotation #void :
  "@" Name "(" =>|| MemberValue ")"
;

INJECT Annotation : 
{
  public String getName() {
    return getChild(1).toString();
  }
}

MemberValuePairs :
   MemberValuePair ( "," MemberValuePair )*
;

MemberValuePair :  <IDENTIFIER> "=" MemberValue;

MemberValue :
   Annotation
   |
   MemberValueArrayInitializer
   | 
   TernaryExpression
;

MemberValueArrayInitializer :
  => "{" "}"
  |
  "{" MemberValue ( "," =>|+1 MemberValue )* [ "," ] "}"
;


/* Annotation Types. */

AnnotationTypeDeclaration #AnnotationTypeDeclaration :
  Modifiers
  "@" "interface" =>|| <IDENTIFIER> AnnotationTypeBody
;

AnnotationTypeBody :
  "{" ( AnnotationTypeMemberDeclaration )* "}"
;

AnnotationTypeMemberDeclaration :
 ";"
 |
 AnnotationTypeDeclaration
 |
 InterfaceDeclaration
 |
 EnumDeclaration
 |
 ClassDeclaration
 |
 Modifiers Type <IDENTIFIER> "(" =>|| ")" [ DefaultValue ] ";"
 |
 FieldDeclaration
;

DefaultValue : "default" MemberValue ;

LambdaExpression : LambdaLHS =>|| (Expression | Block) ;

LambdaLHS : (<IDENTIFIER> | SimpleLambdaLHS | FormalParameters) "->" =>|| ;

SimpleLambdaLHS #void :
   "(" <IDENTIFIER> =>|+1 
   (","<IDENTIFIER>)*
   ")"
;

