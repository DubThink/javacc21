/* Copyright (c) 2008-2020 Jonathan Revusky, revusky@javacc.com
 * Copyright (c) 2006, Sun Microsystems Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notices,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name Jonathan Revusky, Sun Microsystems, Inc.
 *       nor the names of any contributors may be used to endorse or promote
 *       products derived from this software without specific prior written
 *       permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

JAVA_UNICODE_ESCAPE;
TREE_BUILDING_ENABLED;
FREEMARKER_NODES;
PARSER_PACKAGE="com.javacc.parser";
NODE_PACKAGE="com.javacc.parser.tree";
DEFAULT_LEXICAL_STATE=JAVA;
BASE_SRC_DIR="../java";
JDK_TARGET=11;

INJECT PARSER_CLASS :
    import java.util.*;
    import com.javacc.*;
    import com.javacc.lexgen.*;
    import com.javacc.parsegen.*;
    import com.javacc.parser.tree.*;
{
    Grammar grammar;

    public JavaCCParser(Grammar grammar, String inputSource, CharSequence content) {
         this(inputSource, content);
         this.grammar = grammar;
    }

   private char character_descriptor_assign(Token t, String s) {
        if (s.length() != 1) {
            grammar.addParseError(t,
                    "String in character list may contain only one character.");
            return ' ';
        } else {
            return s.charAt(0);
        }
    }

    private char character_descriptor_assign(Token t, String s, String left) {
        if (s.length() != 1) {
            grammar.addParseError(t,
                    "String in character list may contain only one character.");
            return ' ';
        } else if ((int) (left.charAt(0)) > (int) (s.charAt(0))) {
            grammar
                    .addParseError(
                            t,
                            "Right end of character range \'"
                                    + s
                                    + "\' has a lower ordinal value than the left end of character range \'"
                                    + left + "\'.");
            return left.charAt(0);
        } else {
            return s.charAt(0);
        }
    }

    private String removeEscapesAndQuotes(Token t) {
        String retval = "";
        String str = t.getImage();
        int index = 1;
        char ch, ch1;
        int ordinal;
        while (index < str.length() - 1) {
            if (str.charAt(index) != '\\') {
                retval += str.charAt(index);
                index++;
                continue;
            }
            index++;
            ch = str.charAt(index);
            if (ch == 'b') {
                retval += '\b';
                index++;
                continue;
            }
            if (ch == 't') {
                retval += '\t';
                index++;
                continue;
            }
            if (ch == 'n') {
                retval += '\n';
                index++;
                continue;
            }
            if (ch == 'f') {
                retval += '\f';
                index++;
                continue;
            }
            if (ch == 'r') {
                retval += '\r';
                index++;
                continue;
            }
            if (ch == '"') {
                retval += '\"';
                index++;
                continue;
            }
            if (ch == '\'') {
                retval += '\'';
                index++;
                continue;
            }
            if (ch == '\\') {
                retval += '\\';
                index++;
                continue;
            }
            if (ch >= '0' && ch <= '7') {
                ordinal = ((int) ch) - ((int) '0');
                index++;
                ch1 = str.charAt(index);
                if (ch1 >= '0' && ch1 <= '7') {
                    ordinal = ordinal * 8 + ((int) ch1) - ((int) '0');
                    index++;
                    ch1 = str.charAt(index);
                    if (ch <= '3' && ch1 >= '0' && ch1 <= '7') {
                        ordinal = ordinal * 8 + ((int) ch1) - ((int) '0');
                        index++;
                    }
                }
                retval += (char) ordinal;
                continue;
            }
            if (ch == 'u') {
                index++;
                ch = str.charAt(index);
                if (hexchar(ch)) {
                    ordinal = hexval(ch);
                    index++;
                    ch = str.charAt(index);
                    if (hexchar(ch)) {
                        ordinal = ordinal * 16 + hexval(ch);
                        index++;
                        ch = str.charAt(index);
                        if (hexchar(ch)) {
                            ordinal = ordinal * 16 + hexval(ch);
                            index++;
                            ch = str.charAt(index);
                            if (hexchar(ch)) {
                                ordinal = ordinal * 16 + hexval(ch);
                                index++;
                                continue;
                            }
                        }
                    }
                }
                grammar.addParseError(t, "Encountered non-hex character '" + ch
                        + "' at position " + index + " of string "
                        + "- Unicode escape must have 4 hex digits after it.");
                return retval;
            }
            grammar.addParseError(t, "Illegal escape sequence '\\" + ch
                    + "' at position " + index + " of string.");
            return retval;
        }
        return retval;
    }
    
    private static boolean hexchar(char ch) {
    	return (ch >= '0' && ch <= '9') || (ch >= 'A' && ch <= 'F') || (ch >= 'a' && ch <= 'f');
    }
    
    static private int hexval(char ch) {
        if (ch >= '0' && ch <= '9')
            return ((int) ch) - ((int) '0');
        if (ch >= 'A' && ch <= 'F')
            return ((int) ch) - ((int) 'A') + 10;
        return ((int) ch) - ((int) 'a') + 10;
    }    

    static public CompilationUnit parseJavaFile(java.io.Reader input, String inputSource) throws ParseException {
        try {
            String content = FileLineMap.readFully(input);
            return parseJavaFile(inputSource, content);
        } catch (IOException ioe) {
            throw new RuntimeException(ioe);
        }
    }
    
    static public CompilationUnit parseJavaFile(String inputSource, CharSequence content) throws ParseException {
        JavaCCParser parser = new JavaCCParser(inputSource, content);
        return parser.CompilationUnit();
    }

    public Grammar getGrammar() {
        return grammar;
    }
    
    public void openNodeScopeHook(Node n) {
        n.setGrammar(grammar);
    }
}

/* JAVACC RESERVED WORDS: These are the only tokens in JavaCC but not in Java */

TOKEN :
{
  < _INJECT: "INJECT" > #JavaCCKeyWord
  |
  < _INCLUDE : "INCLUDE" | "INCLUDE_GRAMMAR"> #JavaCCKeyWord
  |
  < _LOOKAHEAD: "LOOKAHEAD" > #JavaCCKeyWord
  |
  < _FAIL : "FAIL" > #JavaCCKeyWord
  |
  < _ENSURE : "ASSERT"> #JavaCCKeyWord
  |
  < _SCAN : "SCAN" > #JavaCCKeyWord
  |
  < _IGNORE_CASE: "IGNORE_CASE" > #JavaCCKeyWord
  |
  < _PARSER_BEGIN: "PARSER_BEGIN" > #JavaCCKeyWord
  |
  < _PARSER_END: "PARSER_END" > #JavaCCKeyWord
  |
  < _TOKEN: "TOKEN" | "REGULAR_TOKEN"> #JavaCCKeyWord
  |
  < _SPECIAL_TOKEN: "SPECIAL_TOKEN" | "UNPARSED"> #JavaCCKeyWord
  |
  < _MORE: "MORE" | "INCOMPLETE_TOKEN" > #JavaCCKeyWord
  |
  < _SKIP: "SKIP" > #JavaCCKeyWord
  |
  <_EOF : "EOF"> #JavaCCKeyWord
  |
  < _TOKEN_MGR_DECLS: "TOKEN_MGR_DECLS" > #JavaCCKeyWord
  |
  < _ATTEMPT: "ATTEMPT"> #JavaCCKeyWord
  |
  < _RECOVER : "RECOVER"> #JavaCCKeyWord
  |
  < _RECOVER_TO : "RECOVER_TO"> #JavaCCKeyWord
  |
  < _UPTO : "UPTO"> #JavaCCKeyWord
  |
  <HASH : "#">
  |
//  <HASH_ID : "#"<IDENTIFIER>> #HashID
//  |
  <BACKSLASH : "\\"> #Backslash
  |
  <RIGHT_ARROW : "=>"> #RightArrow
  |
  <UP_TO_HERE : "=>|" ("|" | ("+" ["0"-"9"]))> 
  |
  <_LEXICAL_STATE : "LEXICAL_STATE"> #JavaCCKeyWord
//  |
//  <UP_TO_HERE_PLUS : "=>|+"["0"-"9"]>
}

INJECT BaseNode :
    import java.util.*;
    import freemarker.template.*;
    import java.lang.reflect.*;
    import com.javacc.Grammar;
    import NODE_PACKAGE.KeyWord;
    implements Node, TemplateHashModel, CONSTANTS_CLASS;
{
    public TemplateModel get(String key) throws TemplateModelException {
        String methodName = "get" + key.substring(0,1).toUpperCase() + key.substring(1);
        TemplateModel result = invokeMethod(methodName);
        if (result == null) {
            result = invokeMethod(methodName.replace("get", "is"));
        }
        return result;
   }
    
    private TemplateModel invokeMethod(String methodName) throws TemplateModelException {
        Method method = null;
        try {
            method = this.getClass().getMethod(methodName);
        } catch (NoSuchMethodException e) {
            return null;
        }
        try {
            Object result = method.invoke(this);
            TemplateModel wrappedResult = Configuration.getCurrentObjectWrapper().wrap(result);
            if (methodName.startsWith("is") && !(wrappedResult instanceof TemplateBooleanModel)) {
                return null; //Maybe should throw an exception here, or maybe it doesn't matter.
            }
            return wrappedResult;
        } catch (IllegalAccessException e) {
            throw new TemplateModelException(e);
        } catch (InvocationTargetException e) {
            Throwable cause = e.getCause();
            if (cause instanceof TemplateModelException) {
                throw (TemplateModelException) cause;
            }
            if (cause instanceof Exception) {
                throw new TemplateModelException((Exception) cause);
            }
            throw (Error) cause;
        }
    } 
    
    private Grammar grammar;

    public Grammar getGrammar() {
        if (grammar == null) {
            if (parent != null) {
               grammar = parent.getGrammar();
            }
            if (grammar==null && !children.isEmpty()) {
               grammar = children.get(0).getGrammar();
            }
        }
        return grammar;
    }

    public void setGrammar(Grammar grammar) {
         this.grammar = grammar;
    }
    
    public String getSimpleName() {
        String name = getClass().getName();
        return name.substring(name.lastIndexOf(".") + 1); // strip the package name
    }
    
    protected String getInnerText() {
        StringBuilder buf = new StringBuilder();
        List<Token> tokens = getAllTokens(true);
        boolean outputOpeningBrace = false;
        for (int i=0; i<tokens.size() -1; i++) {
            Token t = tokens.get(i);
            if (outputOpeningBrace) {
                buf.append(t);
            } else if (t.getType() == TokenType.LBRACE) {
                outputOpeningBrace = true;
            }
        }
        return buf.toString();
    }

    // REVISIT. Need to fix the token chaining    
    public void prepend(Node n) {
        ListIterator<Node> iterator = iterator();
        iterator.add(n);
    }
    
    public String getAsString() {
        return getLiteralText();
    }
    
    public boolean isEmpty() {
        return getRealTokens().isEmpty();
    }

    public boolean hasKeyWord(String keyWord) {
        for (KeyWord kw: childrenOfType(KeyWord.class)) {
           if (kw.getImage().equals(keyWord)) return true;
        }
        return false;
    }

    protected String getLiteralText() {
        StringBuilder buf = new StringBuilder();
        for (Token t : getAllTokens(true)) {
            buf.append(t);
        }
        return buf.toString();
    }
}

INJECT CompilationUnit : 
    import java.util.*;
{
    public String getPackageName() {
        PackageDeclaration jpd = getPackageDeclaration();
        return jpd == null ?  null : jpd.getPackageName();
    }
    
    
    public PackageDeclaration getPackageDeclaration() {
        return firstChildOfType(PackageDeclaration.class);
    }
    
    public List<ImportDeclaration> getImportDeclarations() {
        return childrenOfType(ImportDeclaration.class);
    }
    
    public List<TypeDeclaration> getTypeDeclarations() {
        return childrenOfType(TypeDeclaration.class);
    }

    public void addImportDeclaration(ImportDeclaration decl) {
        Node firstTypeDeclaration = firstChildOfType(TypeDeclaration.class);
        if (firstTypeDeclaration == null) {
          firstTypeDeclaration = firstChildOfType(Delimiter.class); //lone semicolon, I suppose
        }
        addChild(indexOf(firstTypeDeclaration), decl);
    }
}

INJECT TypeDeclaration : 
    import java.util.*;
{
    public String getName() {
        return firstChildOfType(Identifier.class).toString();
    }
    
    public TypeParameters getTypeParameters() {
        return firstChildOfType(TypeParameters.class);
    }
    
    public ClassOrInterfaceBody getBody() {
        return firstChildOfType(ClassOrInterfaceBody.class);
    }
    
    public ExtendsList getExtendsList() {
        return firstChildOfType(ExtendsList.class);
    }
    
    public ImplementsList getImplementsList() {
        return firstChildOfType(ImplementsList.class);
    }
    
    public CompilationUnit getCompilationUnit() {
        return firstAncestorOfType(CompilationUnit.class);
    }
    
    public List<ImportDeclaration> getImportDeclarations() {
        CompilationUnit jcu = getCompilationUnit();
        return jcu==null ? new ArrayList<ImportDeclaration>() : jcu.getImportDeclarations();
    }
}

INJECT FormalParameters : 
   import java.util.List;
{
    public List<FormalParameter> getParams() {
        return childrenOfType(FormalParameter.class);
    }
    
    public String getAsString() {
        StringBuilder buf = new StringBuilder();
        List<FormalParameter> params = getParams();
        boolean first = true;
        for (FormalParameter param : params) {
            if (!first) {
                buf.append(", ");
            }
            buf.append(param.getAsString());
            first = false;
        }
        return buf.toString();
    }
    
    public String toString() {
        StringBuilder buf = new StringBuilder();
        for (Token tok : getRealTokens()) {
            buf.append(" ");
            buf.append(tok);
        }
        return buf.toString();
    }
}

INJECT ImplementsList : 
   import java.util.*;
{    
    public List<ObjectType> getTypes() {
        return childrenOfType(ObjectType.class);
    }
    //REVISIT. fix token chaining    
    public void addType(ObjectType type) {
        ListIterator<Node> iterator = iterator();
        if (!iterator.hasNext()) {
            iterator.add(Token.newToken(TokenType.IMPLEMENTS, "implements", this));
            iterator.next();
            iterator.add(type);
        } else {
            while (iterator.hasNext()) {
                if (type.equals(iterator.next())) 
                    return;
            }
            iterator.add(Token.newToken(TokenType.COMMA, ",", this));
            iterator.next();
            iterator.add(type);
        }
    }
}

INJECT CodeBlock :
{
    public String getAsString() {
        return getInnerText();
    }
    
    /**
     * The block is empty if it only consists of { and }
     */
    public boolean isEmpty() {
        return getRealTokens().size() == 2;
    }
}

INJECT InvocationArguments : 
    import java.util.*;
{
    public List<Expression> getArgs() {
        return childrenOfType(Expression.class);
    }

    public String getAsString() {
        StringBuilder buf = new StringBuilder();
        List<Expression> args = getArgs();
        boolean first = true;
        for (Expression arg : args) {
            if (!first) {
                buf.append(", ");
            }
            buf.append(arg.getAsString());
            first = false;
        }
        return buf.toString();
    }
} 


INCLUDE("Java.javacc")

INJECT TypeDeclaration : 
    import java.util.*;
{
    public void addElements(List<ClassOrInterfaceBodyDeclaration> elements) {
        Set<String> keys = new HashSet<String>();
        for (ClassOrInterfaceBodyDeclaration decl : elements) {
            String key = decl.getFullNameSignatureIfMethod();
            if (key != null) {
                keys.add(key);
            }
        }
        //REVISIT. fix token chaining
        for (Iterator<Node> it = getBody().iterator(); it.hasNext();) {
            Node n = it.next();
            if (n instanceof ClassOrInterfaceBodyDeclaration) {
                String s = ((ClassOrInterfaceBodyDeclaration) n).getFullNameSignatureIfMethod();
                if (keys.contains(s)) {
                    it.remove();
                }
            }
        }
        getBody().prepend(elements);
    }
    
   public void addAnnotations(Set<Annotation> annotations) {
       Node parent = this.getParent();
       int index = parent.indexOf(this);
       //REVISIT. fix token chaining
       for (Annotation annotation : annotations) {
           parent.addChild(index, annotation);
       }
   } 
   
    
    public boolean isClass() {
        for (Node n : children) {
	    if (n instanceof Token) {
	       Token t = (Token) n;
               if (t.getType() == TokenType.CLASS) {
                  return true;
               }
	    }
        }
        return false;
    }
    
    public void addImplements(ObjectType type) {
    	ImplementsList implementsList = getImplementsList();
    	if (implementsList == null) {
    	   implementsList = new ImplementsList();
    	   ListIterator<Node> iterator = iterator();
    	   while (iterator.hasNext()) {
    	      Node node = iterator.next();
    	      if (node instanceof ClassOrInterfaceBody || node instanceof EnumBody)
    	          break; 
    	   }
    	   iterator.previous();
    	   iterator.add(implementsList);
    	}
    	implementsList.addType(type);
    }

    public void addExtends(ObjectType type) {
        ExtendsList extendsList = getExtendsList();
        if (extendsList == null) {
            extendsList = new ExtendsList();
            ListIterator<Node> iterator = iterator();
            while (iterator.hasNext()) {
                Node node = iterator.next();
                if (node instanceof ImplementsList || node instanceof ClassOrInterfaceBody) {
                    break;
                }
            }
            iterator.previous();
            iterator.add(Token.newToken(TokenType.WHITESPACE, " ", this));
            iterator.next();
            iterator.add(extendsList);
        }
        extendsList.addType(type, this instanceof InterfaceDeclaration);
    }
}

INJECT ExtendsList : 
     import java.util.*;
{
    //REVISIT. fix token chaining 
    
      public void addType(ObjectType type, boolean isInterface) {
        if (!isInterface) {
            children = new java.util.ArrayList<Node>();
        }
        ListIterator<Node> iterator = iterator();
        if (!iterator.hasNext()) {
            iterator.add(Token.newToken(TokenType.EXTENDS, "extends", this));
            iterator.next();
            iterator.add(type);
        } else {
            while (iterator.hasNext()) {
                if (type.equals(iterator.next())) 
                    return;
            }
            iterator.add(Token.newToken(TokenType.COMMA, ",", this));
            iterator.next();
            iterator.add(type);
        }
    }
}

INJECT TypeParameters : 
    import java.util.*;
{
    // REVISIT. fix token chaining
    
    public void add(TypeParameter param) {
        if (!getParameters().contains(param)) {
            ListIterator<Node> iterator = iterator();
            while(iterator.hasNext()) {
                iterator.next();
            }
            iterator.previous();
            iterator.add(Token.newToken(TokenType.COMMA, ",", this));
            iterator.next();
            iterator.add(param);
        }
    }

    // REVISIT. fix token chaining 
    public void add(TypeParameters params) {
        for (TypeParameter param : params.getParameters()) {
            add(param);
        }
    }
}

INJECT ClassOrInterfaceBody : 
    import java.util.*;
{
    public String getAsString() {
        return getInnerText();
    }
    
    // REVISIT. fix token chaining
    public void prepend(List<ClassOrInterfaceBodyDeclaration> elements) {
        ListIterator<Node> iterator = iterator();
        Node n = null;
        while (iterator.hasNext()) {
            n = iterator.next();
      	    if (n instanceof Token) {
	          Token t = (Token) n;
               if (t.getType() == TokenType.LBRACE) {
                   break;
               }
	          }
        }
        for (ClassOrInterfaceBodyDeclaration elem : elements) {
            iterator.add(elem);
            iterator.next();
        }
    }
    
    // REVISIT. fix token chaining 
    public void removeDuplicateMethods() {
        Set<String> sigs = new HashSet<String>();
        ListIterator<Node> decls = iterator();
        while (decls.hasNext()) {
           Node n = decls.next();
           if (n instanceof ClassOrInterfaceBodyDeclaration) {
               ClassOrInterfaceBodyDeclaration decl = (ClassOrInterfaceBodyDeclaration) n;
               String sig = decl.getFullNameSignatureIfMethod();
               if (sig != null) {
                    if (sigs.contains(sig)) {
                        decls.remove();
                    } else {
                        sigs.add(sig);
                    }
               }
           }
        }
    }
}

INJECT ClassOrInterfaceBodyDeclaration : 
{
    public boolean isMethod() {
        return firstChildOfType(MethodDeclaration.class) != null;
    }
    
    public String getFullNameSignatureIfMethod() {
        MethodDeclaration md = firstChildOfType(MethodDeclaration.class);
        return md == null ? null : md.getFullSignature();
    }
}

INJECT FieldDeclaration : 
   import java.util.*;
   extends ClassOrInterfaceBodyDeclaration
{
  public List<Identifier> getVariableIds() {
    return descendants(Identifier.class, n->n.getParent() instanceof VariableDeclaratorId);
  }
}


INJECT PARSER_CLASS : {

    private EnumSet<TokenType> javaccKeyWords = EnumSet.of(_INJECT,
       _INCLUDE, _LOOKAHEAD, _FAIL, _ENSURE, _SCAN, _IGNORE_CASE, 
       _PARSER_BEGIN, _PARSER_END, _TOKEN, _SPECIAL_TOKEN, _MORE,
       _SKIP, _TOKEN_MGR_DECLS, _ATTEMPT, _RECOVER, _UPTO, 
       _LEXICAL_STATE, _EOF);


    private Token TOKEN_HOOK(Token tok) {
        TokenType type = tok.getType();
        if ((type == RSIGNEDSHIFT || type == RUNSIGNEDSHIFT) && !isInProduction("Expression")) {
          Token gt = Token.split(tok, 1, GT, GT);
          if (type == RUNSIGNEDSHIFT) {
              Token.split(gt.getNextToken(), 1, GT, GT);
          }
          return gt;
        } 
        return tok;
    }

    private Token TOKEN_HOOK(Token t) {
        if (javaccKeyWords.contains(t.getType())) {
            if (isInProduction("CompilationUnit", "ClassOrInterfaceBody", "BlockStatement", "TreeBuildingAnnotation")) {
               if (t.getType() != _PARSER_END || !isInProduction("ParserCodeDecls")) {
	               Token id = Token.newToken(IDENTIFIER, t.getImage(), this);
	               id.copyLocationInfo(t);
	               return id;
               }
           }
        }
        t.setGrammar(getGrammar());
        return t;
    }
}

INJECT CaseStatement :
{
    // If the case statement has an unreachable break statement at the
    // end, we remove it. This allows us to get rid of this horrid longstanding kludge
    // This is no longer used! I leave it here for historical reasons! 
    // See: https://parsers.org/t/a-fun-example-of-code-injection-at-work/30
    public void close() {
        if (getChildCount() >= 2) {
            Node last = this.getLastChild();
            Node secondLast = this.getChild(getChildCount() -2);
            if ((last instanceof BreakStatement) && (secondLast instanceof ReturnStatement)) {
                removeChild(last);
            }
        }
    }
}

INJECT MethodDeclaration : 
{
    public String getName() {
        for (Node n : children) {
            if (n instanceof Identifier) {
                return n.toString();
            }
        }
        throw new IllegalStateException();
    }
    
    public FormalParameters getFormalParameters() {
        return firstChildOfType(FormalParameters.class);
    }
    
    public String getFullSignature() {
        return getName() + getFormalParameters();
    }
}

INJECT ThrowsList : 
    import java.util.List;
    import java.util.ArrayList;
{
    public List<Node> getTypes() {
        List<Node> result = new ArrayList<>();
        for (Node n : children) {
           if ((n instanceof Name) || (n instanceof Identifier)) {
              result.add(n);
           }
        }
        return result; 
    }
}

INJECT Identifier : 
{
    private String tokenHookName, openHookName, closeHookName;

   public String getNormalizedText() {
        String image = getImage();
        if (image.equals("jjtThis") || image.equals("CURRENT_NODE")) { 
            return getGrammar().getCurrentNodeVariableName();
        }
        if (image.equals("PARSER_CLASS")) {
            return getGrammar().getParserClassName();
        }
        if (image.equals("LEXER_CLASS")) {
            return getGrammar().getLexerClassName();
        }
        if (image.equals("CONSTANTS_CLASS")) {
            return getGrammar().getConstantsClassName();
        }
        if (image.equals("NODE_PACKAGE")) {
            return getGrammar().getNodePackage();
        }
        if (image.equals("PARSER_PACKAGE")) {
            return getGrammar().getParserPackage();
        }
        if (image.equals("current_token")) {
            return "lastConsumedToken";
        }
        if (image.equals("TOKEN_HOOK")) {
            if (tokenHookName ==null) {
                tokenHookName = getGrammar().generateUniqueIdentifier("tokenHook$", this);
            }
            return tokenHookName;
        }
        if (image.equals("OPEN_NODE_HOOK")) {
            if (openHookName == null) {
                openHookName = getGrammar().generateUniqueIdentifier("openNodeHook$", this);
            }
            return openHookName;
        }
        if (image.equals("CLOSE_NODE_HOOK")) {
            if (closeHookName == null) {
                closeHookName = getGrammar().generateUniqueIdentifier("closeNodeHook$", this);
            }
            return closeHookName;
        }
        return image;
   }
}

INJECT interface Node :
   import com.javacc.Grammar;
{
   Grammar getGrammar();
   void setGrammar(Grammar grammar);
}


INJECT Token :
    import com.javacc.Grammar;
{
    private Grammar grammar;

    public Grammar getGrammar() {
        if (grammar == null) {
           if (parent != null) {
              grammar = parent.getGrammar();
           }
        }
        return grammar;
    }

    public void setGrammar(Grammar grammar) {
         this.grammar = grammar;
    }
    
    public String getNodeName() {
        return getType().toString();
    }
    
    public String getLeadingComments() {
        Token specialToken = getPreviousToken() == null || !getPreviousToken().isUnparsed() ? null : getPreviousToken();
        if (specialToken == null)
            return "";
        StringBuilder buf = new StringBuilder();
        Token tok = specialToken;
        while (tok.getPreviousToken() != null && tok.getPreviousToken().isUnparsed()) {
            tok = tok.getPreviousToken();
        }
        while (tok != this && tok != null) {
            buf.append(tok);
            tok = tok.getNext();
        }
        return buf.toString();
    }
    
    public String getNormalizedText() {
        if (getType() == TokenType.IDENTIFIER) {
            if (image.equals("jjtThis") || image.equals("CURRENT_NODE")) { 
                return getGrammar().getCurrentNodeVariableName();
            }
        } 
        return image;
    }
}

#Root throws IOException #GrammarFile :
{
    TokenManagerDecls decls;
    TokenProduction tp;
}
{
   [
      OptionsBlock | Options
   ]
   [ParserCodeDecls]
   (
      SCAN {!grammar.getUserDefinedLexer()} =>
      tp=TokenProduction  {grammar.addTokenProduction(tp);}
      |
      BNFProduction
      |
      decls=TokenManagerDecls {grammar.addCodeInjection(decls);}
      |
      CodeInjection2 
      |
      CodeInjection
      |
      GrammarInclusion
  )+
  <EOF>
  {
        return CURRENT_NODE;
  }
}

ParserCodeDecls : 
{
    Token id;
    CompilationUnit parserCode;
}
{
   "PARSER_BEGIN"
   "("
   id=<IDENTIFIER>
   ")"
   {
      if (!grammar.isInInclude())
          grammar.setParserClassName(id.getImage());
   }
   parserCode=CompilationUnit
   {
       if (!grammar.isInInclude())
           grammar.setParserCode(parserCode);
   }
   "PARSER_END" ["(" <IDENTIFIER> ")"]
}

INJECT ReturnType :
    import java.util.List;
{
    public boolean getAsBoolean() {
        List<Token> lt = getRealTokens();
        return lt.size() != 1 || lt.get(0).getType() != VOID;
    }
}

INJECT PARSER_CLASS : {
    private boolean enterIncludes = true;
    public void setEnterIncludes(boolean enterIncludes) {this.enterIncludes = enterIncludes;}
}

GrammarInclusion throws IOException :
{
   Token t;
}
   <_INCLUDE>
   (
       t=<STRING_LITERAL>
       |
       "(" t=<STRING_LITERAL> ")"
   )
   {
      String location = t.getImage().substring(1, t.getImage().length() -1);
      if (enterIncludes) {
          CURRENT_NODE.addChild(grammar.include(location));
      }
   }
;

CodeInjection :
{
    boolean isInterface = false;
    Annotation annotation = null;
    boolean foundOptionalInitialBrace = false;
    boolean usingParentheses = false;
    ImportDeclaration id;
    ObjectType ot;
    Annotation ann;
    ClassOrInterfaceBody coib;
}   
        "INJECT" ["(" {usingParentheses = true;}]
        [
            "class"
            |
            "interface" {isInterface = true;}
        ]
        <IDENTIFIER> {CURRENT_NODE.name = lastConsumedToken.toString();} 
        [
            SCAN {usingParentheses} => ")"
        ]
        ":"
        [
          SCAN "{"("import"|"@"|"extends"|"implements"|"}") => "{" 
          {foundOptionalInitialBrace=true;}
        ]
        (
            id=ImportDeclaration {CURRENT_NODE.importDeclarations.add(id);}
        )*
        (
            ann=Annotation {CURRENT_NODE.annotations.add(ann);}
        )*
        [
             "extends" 
             ot=ObjectType {CURRENT_NODE.addExtendsType(ot);}
             (SCAN {isInterface} => "," ot=ObjectType {CURRENT_NODE.addExtendsType(ot);})*
             [";"]
        ]
        [
             SCAN {!isInterface} =>
             "implements" ot=ObjectType {CURRENT_NODE.addImplementsType(ot);}
             ("," ot=ObjectType {CURRENT_NODE.addImplementsType(ot);})*
             [";"]
        ]
        [
           SCAN {foundOptionalInitialBrace} => "}"
        ]
        [coib=ClassOrInterfaceBody {CURRENT_NODE.body = coib;}]
        {
                if (enterIncludes) {
                    grammar.addCodeInjection(CURRENT_NODE);
                }
        }
;

INJECT CodeInjection : 
   import java.util.List;
   import java.util.ArrayList;
{
   public String name;
   public List<ImportDeclaration> importDeclarations = new ArrayList<ImportDeclaration>();
   public List<Annotation> annotations = new ArrayList<>();
   public List<ObjectType> extendsList = new ArrayList<>();
   public List<ObjectType> implementsList = new ArrayList<>();
   public ClassOrInterfaceBody body;
   public boolean isInterface;   

   public void addExtendsType(ObjectType type) {extendsList.add(type);}
   public void addImplementsType(ObjectType type) {implementsList.add(type);}
}

CodeInjection2 :
{
        CompilationUnit jcu;
}
        <_INJECT>
        ":" =>|| "{"
        jcu=CompilationUnit
       "}"
        {
                if (enterIncludes) {
    				grammar.addCodeInjection(jcu);
                }
        }
;

Options #Options :
    {HashMap<String, Object> settings = new HashMap<>();} 
    Setting(settings) =>||
    (Setting(settings))*
    {grammar.setSettings(settings);}
;

OptionsBlock #Options :
    {HashMap<String, Object> settings = new HashMap<>();} 
    <IDENTIFIER> 
    [
        SCAN {!getToken(0).getImage().equalsIgnoreCase("options")}#
        => FAIL "Expecting \"options\" here"
    ]
    =>||
    [":"]
    "{" 
    ( Setting (settings) )* "}"
    {grammar.setSettings(settings);}
;

Setting(Map settings) #Setting :
{
	  String key;
	  Token name, t=null;
	  boolean inInclude = grammar.isInInclude();
	  Object value = Boolean.TRUE;
}
  ( 
     name = <IDENTIFIER> 
     | 
     name = <_IGNORE_CASE>
  )
  =>|+1
  {
	  key = name.getImage().toUpperCase();
  }
  [
     "="
     (
        t="true" {value=true;}
        |
        t="false" {value=false;}
        |
        t= <INTEGER_LITERAL> {value = Integer.valueOf(t.getImage());}
        |
        t= <STRING_LITERAL> {value = removeEscapesAndQuotes(t);}
        |
        t= <IDENTIFIER> {value = t.getImage();}
     )
  ]  
  ";"
  {
      settings.put(key, value);
  }
;

BNFProduction :
{
    TreeBuildingAnnotation tba = null;
    Token firstToken=getToken(1), id;
    Expansion exp;
}
    [
        "public" | "private" | "protected"
    ]
    [
       SCAN ReturnType <IDENTIFIER> => ReturnType
       |
       "#" {CURRENT_NODE.setImplicitReturnType(true);}
    ]
    id=<IDENTIFIER> {CURRENT_NODE.setName(id.getImage());}
    [FormalParameters]
    [
      ThrowsList
    ]
    [
        tba=TreeNodeDescriptor 
        {
            String nodeName = tba.getNodeName();
            if (nodeName == null) nodeName = CURRENT_NODE.getNodeName();
            grammar.addNodeType(CURRENT_NODE.getName(), nodeName);
        }
    ]
    [
        "RECOVER_TO" ExpansionChoice
        {CURRENT_NODE.setRecoveryExpansion((Expansion)peekNode());} 
    ]
    ":"
    (
        // Older syntax
        => [=>Block] "{" ExpansionChoice {CURRENT_NODE.setExpansion((Expansion) peekNode());} "}"
        |
        [Block]
        ExpansionChoice 
        {CURRENT_NODE.setExpansion((Expansion) peekNode());} ";"
    )
    {
        CURRENT_NODE.adjustFirstToken(firstToken);
        if (tba == null && !grammar.getNodeDefaultVoid()) {
           grammar.addNodeType(CURRENT_NODE.getName(),CURRENT_NODE.getName());
        }
     }
;

INJECT BNFProduction : 
	import java.util.*;
	import com.javacc.parsegen.TokenSet;
	import com.javacc.parsegen.Expansion;
{
    @Property boolean implicitReturnType;
//    public void CLOSE_NODE_HOOK() {} //FIXME

    public boolean getHasScanLimit() {
        return expansion instanceof ExpansionSequence && ((ExpansionSequence) expansion).getHasScanLimit();
    }

    public boolean getHasExplicitLookahead() {
        return expansion.getHasExplicitLookahead();
    }

    public CodeBlock getJavaCode() {
       return firstChildOfType(CodeBlock.class);
    }
    
    public TreeBuildingAnnotation getTreeBuildingAnnotation() {
        return firstChildOfType(TreeBuildingAnnotation.class);
    }
    
    public String getNodeName() {
        TreeBuildingAnnotation tba = getTreeBuildingAnnotation();
        if (tba != null) {
             String nodeName = tba.getNodeName();
             if (nodeName != null && !nodeName.equals("abstract") 
                 && !nodeName.equals("interface")
                 && !nodeName.equals("void")) {
                return nodeName;
             }
        }
        return this.getName();
    }

    private String leadingComments="";

    @Property Expansion expansion, recoveryExpansion;
    @Property String name;

    public ThrowsList getThrowsList() {
        return firstChildOfType(ThrowsList.class);
    }
    
    public FormalParameters getParameterList() {
        return firstChildOfType(FormalParameters.class);
    }
    
    public TreeBuildingAnnotation getTreeNodeBehavior() {
        return firstChildOfType(TreeBuildingAnnotation.class);
    }


    /**
     * The NonTerminal nodes which refer to this production.
     */
    private List<NonTerminal> referringNonTerminals;
    
    public List<NonTerminal> getReferringNonTerminals() {
        if (referringNonTerminals == null) {
           referringNonTerminals = getGrammar().descendants(NonTerminal.class, nt->nt.getName().equals(name));
        }
        return referringNonTerminals;
    }

    public String getLookaheadMethodName() {
        return "check$" + name;
    }

    /**
     * Can this production be matched by an empty string?
     */
    public boolean isPossiblyEmpty() {
         return getExpansion().isPossiblyEmpty();
    }

    public String getAccessModifier() {
        for (Token t : childrenOfType(Token.class)) {
           TokenType type = t.getType();
           if (type == PRIVATE) {
               return "private";
           }
           else if (type == PROTECTED) {
               return "protected";
           }
           else if (type == PACKAGE) {
               return "";
           }
        }
        return "public";
    }

    public String getReturnType() {
        if (isImplicitReturnType()) {
            return getNodeName();
        }
        ReturnType rt = firstChildOfType(ReturnType.class);
        return rt == null ? "void" : rt.getAsString();
    }
    
    public void adjustFirstToken(Token t) {
        //FIXME later. Not very urgent.
/*        
        Token firstToken = firstChildOfType(Token.class);
        if (firstToken != t) {

        }
        if (firstChildOfType(Token.class) !== t)
        this.leadingComments = t.getLeadingComments();
*/
    }

    public String getLeadingComments() {
        return leadingComments;
    }
    
    private TokenSet firstSet, finalSet;
    
    public TokenSet getFirstSet() {
        if (firstSet == null) {
           firstSet = getExpansion().getFirstSet();
        }
        return firstSet;
    }

    public String getFirstSetVarName() {
        return getName() + "_FIRST_SET";
    }
    
    public TokenSet getFinalSet() {
          if (finalSet == null) {
              finalSet = getExpansion().getFinalSet();
          }
          return finalSet;
    }
    
    public boolean isConcrete() {
       return getExpansion().isConcrete();
    }
}

//TreeBuildingAnnotation 
TreeNodeDescriptor #TreeBuildingAnnotation :
  "#" [<IDENTIFIER>|"abstract"|"interface"|"void"]
   [
	   "("
	      [
	        ">"
	      ]
	      Expression()
	   ")"
  ]
//  {
//          return CURRENT_NODE;
//  }
;

INJECT TreeBuildingAnnotation :
{
    /**
     * Just returns whatever comes after the hash ("#") including "void", etc.
     */
    public String getNodeName() {
        Token hash = firstChildOfType(TokenType.HASH);
        if (hash == null) return null;
        Token nextToken = hash.getNext();
        TokenType nextType = nextToken.getType();
        if (nextType != IDENTIFIER 
            && nextType != ABSTRACT 
            && nextType != INTERFACE 
            && nextType != VOID) return null;
        return nextToken.getImage();
    }

    public boolean isNeverInstantiated() {
        return isVoid() || isAbstract() || isInterface();
    }

    public Expression getCondition() {
        return firstChildOfType(Expression.class);
    }
    
    public boolean getGtNode() {
        return firstChildOfType(GT) != null;
    }

    public boolean isAbstract() {
        return "abstract".equals(getNodeName());
    }

    public boolean isInterface() {
        return "interface".equals(getNodeName());
    }
    
    public boolean isVoid() {
        return "void".equals(getNodeName());
    }
}


TokenProduction #TokenProduction :
{
    Token t = null;
    String tokenClassName = null;
    String firstSpecifiedLexicalState = null;
    boolean multipleStatesSpecified = false, useBraces = false;
    boolean ignoreCase = false;
}
{
  [
    => "<" "*" ">" {multipleStatesSpecified = true;} 
    |
    "<"
      <IDENTIFIER>{
          firstSpecifiedLexicalState = lastConsumedToken.getImage();
          grammar.addLexicalState(firstSpecifiedLexicalState);
      }
      ("," <IDENTIFIER> {multipleStatesSpecified = true; grammar.addLexicalState(lastConsumedToken.getImage());})*
    ">"
  ]
  (<_TOKEN> | <_SPECIAL_TOKEN> | <_MORE> | "SKIP")
  [
    "[" "IGNORE_CASE" {ignoreCase = true;} "]"
  ]
  ["#" t = <IDENTIFIER> {tokenClassName=t.getImage();}] 
  ":"
  ["{" {useBraces = true;}]
   RegexpSpec(CURRENT_NODE, tokenClassName)
   ( "|" RegexpSpec(CURRENT_NODE, tokenClassName) )*
   (
      SCAN {useBraces} => "}" 
      | 
      ";"
   )
   {
      if (!multipleStatesSpecified) {
          if (firstSpecifiedLexicalState == null) {
              firstSpecifiedLexicalState = grammar.getDefaultLexicalState();
          }
          CURRENT_NODE.setImplicitLexicalState(firstSpecifiedLexicalState);
      }
      CURRENT_NODE.setIgnoreCase(ignoreCase || grammar.isIgnoreCase());
   }
}

INJECT TokenProduction :
    import java.util.*;
    import com.javacc.lexgen.LexerData;
    import com.javacc.lexgen.LexicalStateData;
{
   @Property private boolean explicit=true, ignoreCase;

    private String implicitLexicalState;
    
    public void setImplicitLexicalState(String implicitLexicalState) {
        this.implicitLexicalState = implicitLexicalState;
    }

    public List<RegexpSpec> getRegexpSpecs() {
        return childrenOfType(RegexpSpec.class);
    }

    /**
     * The states in which this regular expression production exists.
     */
    public String[] getLexicalStateNames() {
    
        if (implicitLexicalState != null) {
            return new String[] {implicitLexicalState};
        }        
        if (isInAllLexStates()) {
     	    return getGrammar().getLexicalStates();
        }
        Set<String> states = new LinkedHashSet<String>();
        for (Token t : childrenOfType(Token.class)) {
            if (t.getType() == IDENTIFIER) {
                states.add(t.getImage());
            }
        }
        if (states.isEmpty()) {
           return new String[] {getGrammar().getDefaultLexicalState()};
        }
        String[] lexStates = new String[states.size()];
        int i=0;
        for (String s : states) {
           lexStates[i++] = s;
        } 
        return lexStates;
    }
    
    private boolean isInAllLexStates() {
       for (Node n : children) {
          if (n instanceof Token) {
	      Token t = (Token) n;
              if (t.getType() == STAR) {
                  return true;
              }
	      }
       }
       return false;
    }

    public String getKind() {
       for (Token t : childrenOfType(Token.class)) {
	       switch (t.getType()) {
	          case _MORE : return "MORE";
	          case _SPECIAL_TOKEN : return "SPECIAL_TOKEN";
	          case _SKIP : return "SKIP";
	          case _TOKEN : return "TOKEN";
	          default: 
	       }
      }
      return "TOKEN";
    }
}

TokenManagerDecls :
   "TOKEN_MGR_DECLS" ":"
    ClassOrInterfaceBody
;

RegexpSpec(TokenProduction p, String tokenClassName) #RegexpSpec :
{
    RegularExpression regexp;
}
  RegexpExpansion 
  {
      regexp = (RegularExpression) peekNode();
      CURRENT_NODE.addChild(popNode());
      if (tokenClassName != null) {
          regexp.setGeneratedClassName(tokenClassName);
      }
  }
  [
     "#"<IDENTIFIER>
     {
        regexp.setGeneratedSuperClassName(tokenClassName);
        regexp.setGeneratedClassName(lastConsumedToken.getImage());
     }
  ]
  [
      SCAN {!regexp.isPrivate()} \...\TokenProduction =>
      Block
  ]
  [ 
      SCAN {!regexp.isPrivate()} \...\TokenProduction =>
      ":" <IDENTIFIER>
  ]
;

INJECT RegexpSpec : 
   import com.javacc.parsegen.RegularExpression;
{
    public String getNextState() {
        Token nsTok = getNsTok();
        return nsTok == null ? null : nsTok.toString();
    }

    public Token getNsTok() {
        Token colon = firstChildOfType(COLON);
        return colon == null ? null : colon.getNext();
    }

    public RegularExpression getRegexp() {
         return firstChildOfType(RegularExpression.class);
    }

    public CodeBlock getCodeSnippet() {
        return firstChildOfType(CodeBlock.class);
    }
}

ExpansionChoice : 
  ExpansionSequence
  ( "|" ExpansionSequence)*
;

INJECT ExpansionChoice : 
   import com.javacc.parsegen.Expansion;
   import com.javacc.parsegen.TokenSet;
   import java.util.List;
   extends Expansion implements Expansion.ChoicePoint;
{
   public List<Expansion> getChoices() {
       return childrenOfType(Expansion.class);
   }
   
   public TokenSet getFirstSet() {
        if (firstSet == null) {
           firstSet = new TokenSet(getGrammar());
           for (Expansion choice : getChoices()) {
//               firstSet.or(choice.getFirstSet());
               firstSet.or(choice.getLookaheadExpansion().getFirstSet());
           }
        }
        return firstSet;
   }
   
   private TokenSet finalSet;
    
   public TokenSet getFinalSet() {
       if (finalSet == null) {
           finalSet = new TokenSet(getGrammar());
           for (Expansion choice : getChoices()) {
               finalSet.or(choice.getFinalSet());
           }
       }
       return finalSet;
   }
   
   
   public boolean isPossiblyEmpty() {
        for (Expansion e : getChoices()) {
            if (e.isPossiblyEmpty()) {
                return true;
            }
        }
        return false;
   }
   
   public int minimumSize(int min) {
      for (Expansion nestedExpansion : getChoices()) {
       	if (min<=0 || nestedExpansion instanceof Failure) break;
        	min = Math.min(min, nestedExpansion.minimumSize(min));
        }
        return min;
   }

   public int getMaximumSize() {
       int result = 0;
       for (Expansion exp : getChoices()) {
           result = Math.max(result, exp.getMaximumSize());
           if (result == Integer.MAX_VALUE) break;
       }
       return result;
   }
   
   public boolean isConcrete() {return false;} 

   public boolean isAlwaysSuccessful() {
       if (!super.isAlwaysSuccessful()) return false;
       for (Expansion choice : getChoices()) {
           if (choice.isAlwaysSuccessful()) return true;
       }
       return false;
   }
}

ExpansionWithParentheses :
{
//    Expansion nestedExpansion;
    Token start;
}
   start="("
   ExpansionChoice// {nestedExpansion = (Expansion) peekNode();}
   ")"
   [
       "*" {CURRENT_NODE = new ZeroOrMore();}
       |
       "?" {CURRENT_NODE = new ZeroOrOne();}
       |
       "+" {CURRENT_NODE = new OneOrMore();}
   ]
   [SCAN ~\...\Lookahead => UpToHere(CURRENT_NODE)]
   [
       SCAN ~\...\Lookahead => 
       "!" {CURRENT_NODE.setTolerantParsing(true);}
   ]
   {
       CURRENT_NODE.copyLocationInfo(start, lastConsumedToken);
   }
;

INJECT ExpansionWithParentheses : 
   import com.javacc.parsegen.TokenSet;
   import com.javacc.parsegen.Expansion;
   extends Expansion
{
    public boolean isConcrete() {return getNestedExpansion().isConcrete();}
    public int getMaximumSize() {return getNestedExpansion().getMaximumSize();}
    public int minimumSize(int min) {return getNestedExpansion().minimumSize(min);}
    public boolean isPossiblyEmpty() {return getNestedExpansion().isPossiblyEmpty();}
    public TokenSet getFirstSet() {return getNestedExpansion().getFirstSet();}
    public TokenSet getFinalSet() {return getNestedExpansion().getFinalSet();}

    public Expansion getNestedExpansion() {
        return firstChildOfType(Expansion.class);
    }
}

ExpansionSequence #ExpansionSequence :
{
   Expansion sub;
   Lookahead la = null;
}
{
  [ 
    SCAN ~\...\Lookahead 
    =>
    la=Lookahead
    {
       la.setExpansion(CURRENT_NODE);
       CURRENT_NODE.setLookahead(la);
     }
  ]
  (
     SCAN ~(<BIT_OR>|<COMMA>|<RPAREN>|<RBRACE>|<RBRACKET>|<SEMICOLON>|<RIGHT_ARROW>|<SLASH>|<BACKSLASH>)
     => sub=ExpansionUnit
      {
          pokeNode(sub);
      }
  )+
}

INJECT ExpansionSequence : 
   import com.javacc.Grammar;
   import com.javacc.parsegen.Expansion;
   import com.javacc.parsegen.TokenSet;
   import java.util.*;
   extends Expansion;
{
   public ExpansionSequence(Grammar grammar) {
       setGrammar(grammar);
   }

   public ExpansionSequence() {}


   public List<Expansion> getUnits() {
       return childrenOfType(Expansion.class);
   }

   public boolean isAlwaysSuccessful() {
       if (!super.isAlwaysSuccessful()) return false;
       for (Expansion unit : getUnits()) {
           if (!unit.isAlwaysSuccessful()) return false;
       }
       return true;
   }

   public TokenSet getFirstSet() {
       if (firstSet == null) {
           firstSet = new TokenSet(getGrammar());
           for (Expansion child : getUnits()) {
               firstSet.or(child.getFirstSet());
               if (!child.isPossiblyEmpty()) {
                  break;
               }
           }
       }
       return firstSet;
   }
//   private TokenSet finalSet;
   public TokenSet getFinalSet() {
       TokenSet finalSet = null; // REVISIT, not sure why this is necessary
       if (finalSet == null) {
           finalSet = new TokenSet(getGrammar());
           List<Expansion> children = getUnits();
           Collections.reverse(children);
           for (Expansion child : children) {
               finalSet.or(child.getFinalSet());
               if (!child.isPossiblyEmpty()) {
                  break;
               }
           }
       }
       return finalSet;
   }

   public boolean getRequiresScanAhead() {
       boolean foundNonEmpty = false;
       for (Expansion unit : getUnits()) {
            if (unit.isScanLimit()) return true;
            if (!foundNonEmpty && (unit instanceof NonTerminal)) {
                NonTerminal nt = (NonTerminal) unit;
                if (nt.getHasScanLimit()) return true;
            }
            if (!unit.isPossiblyEmpty()) foundNonEmpty = true;
       }
       Lookahead la = getLookahead();
       return la != null && la.getRequiresScanAhead();
   }

   public boolean isPossiblyEmpty() {
        for (Expansion e : getUnits()) {
            if (!e.isPossiblyEmpty()) {
                return false;
            }
        }
        return true;
   }

    public int minimumSize(int oldMin) {
          int min = 0;
          for (Expansion eseq : getUnits()) {
              int mineseq = eseq.getMinimumSize();
              if (min == Integer.MAX_VALUE || mineseq == Integer.MAX_VALUE) {
                  min = Integer.MAX_VALUE; // Adding infinity to something results in infinity.
              } else {
                  min += mineseq;
                  if (min > oldMin)
                      break;
              }
          }
          return min;
   }

    public int getMaximumSize() {
       int result = 0;
       for (Expansion exp : getUnits()) {
           int max = exp.getMaximumSize();
           if (max == Integer.MAX_VALUE) return Integer.MAX_VALUE;
           result += max;
       }
       return result;
   }
   
   public boolean isConcrete() {
      for (Expansion exp : getUnits()) {
         if (!exp.isConcrete()) {
            return false;
         }
      }
      return true;
   }
   
   public boolean isSingleton() {
       return getUnits().size() == 1 && getLookahead() == null;
   }
  /* 
  // need to REVISIT this.
   public String getFirstSetVarName() {
       if (isSingleton()) {
          NonTerminal nt = firstChildOfType(NonTerminal.class);
          if (nt != null) {
              return nt.getFirstSetVarName();
          }
       }
       return super.getFirstSetVarName();
   }*/
   
}

Lookahead Lookahead #void :
(<RIGHT_ARROW>#Lookahead | ScanAhead | LegacyLookahead) 
{
    return (Lookahead) peekNode();
};

INJECT Assertion : 
   import com.javacc.parsegen.Expansion;
   import com.javacc.parsegen.TokenSet;
   extends Expansion 
{
    private Expression semanticLookahead;
    private LookBehind lookBehind;
    private Expansion expansion;
    private boolean semanticLookaheadNested, expansionNegated;
    private String message = "Assertion failed";

    public Expansion getExpansion() {return expansion;}
    public LookBehind getLookBehind() {return lookBehind;}
    public Expression getSemanticLookahead() {return semanticLookahead;}
    public boolean getSemanticLookaheadNested() {return semanticLookaheadNested;}
    public boolean getExpansionNegated() {return expansionNegated;}
    public String getMessage() {return message;}
    public void setSemanticLookahead(Expression semanticLookahead) {this.semanticLookahead = semanticLookahead;}
    public void setLookBehind(LookBehind lookBehind) {this.lookBehind = lookBehind;}
    public void setExpansion(Expansion expansion) {this.expansion = expansion;}
    public void setExpansionNegated(boolean expansionNegated) {this.expansionNegated = expansionNegated;}
    public void setSemanticLookaheadNested(boolean semanticLookaheadNested) {this.semanticLookaheadNested = semanticLookaheadNested;}
    public void setMessage(String message) {this.message = message;}

    public boolean getRequiresScanAhead() {
        return false;
    }
    
    public boolean isPossiblyEmpty() {
        return true;
    }
    
    public TokenSet getFirstSet() {return new TokenSet(getGrammar());}
    
    public TokenSet getFinalSet() {return new TokenSet(getGrammar());}
     
     public int minimumSize(int unused) {
         return 0;
     }

     public int getMaximumSize() {
         return 0;
     }

    public boolean isConcrete() {return false;}
}


Assertion Assertion :
   {
       Expression exp = null;
       LookBehind lb = null;
       Expansion expansion = null;
       Token messageToken;
   }
   "ASSERT"
   [
    "{" 
    exp=Expression {CURRENT_NODE.setSemanticLookahead(exp);}
    "}"
    ["#" {CURRENT_NODE.setSemanticLookaheadNested(true);}]
   ]  
   [=>LookBehind {lb = (LookBehind) peekNode(); CURRENT_NODE.setLookBehind(lb);}]
   [
       ["~" {CURRENT_NODE.setExpansionNegated(true);}] 
       ExpansionChoice {expansion = (Expansion) peekNode(); CURRENT_NODE.setExpansion(expansion);}
   ]
   [
       SCAN {exp == null && lb == null && expansion == null}
       => FAIL "Assertion is empty!"
   ]
   ":" 
   messageToken=<STRING_LITERAL> {CURRENT_NODE.setMessage(removeEscapesAndQuotes(messageToken));}
   {
       return CURRENT_NODE;
   }
;

Lookahead ScanAhead #Lookahead : 
{
   Token amountToken=null;
   boolean hasSemanticLookahead = false;
   Expansion expansion = null, upToExpansion = null;
   Expression exp=null;
   Node lb = null;
}
[=>exp=PrimaryExpression "=" {CURRENT_NODE.setLHS(exp);}]
<_SCAN>
[
    amountToken= <INTEGER_LITERAL>
    {
        CURRENT_NODE.setAmount(Integer.parseInt(amountToken.getImage()));
    }
]
[
    "{" 
    exp=Expression {hasSemanticLookahead = true; CURRENT_NODE.setSemanticLookahead(exp);}
    "}"
    ["#" {CURRENT_NODE.setSemanticLookaheadNested(true);}]
]
/*
[
   <_UPTO> 
   ExpansionChoice 
   {
       upToExpansion = (Expansion) peekNode();
       CURRENT_NODE.setUpToExpansion(upToExpansion);
   }
]*/
[SCAN LookBehind {lb = peekNode();}]
[
    SCAN {amountToken == null} => 
    ["~" {CURRENT_NODE.setNegated(true);}] 
    ExpansionChoice {expansion = (Expansion) peekNode();}
    <RIGHT_ARROW>
    {
       CURRENT_NODE.setNestedExpansion(expansion);
       expansion.setLookahead(CURRENT_NODE);
    }
]
(
    SCAN {expansion == null} => <RIGHT_ARROW>
    |
    SCAN {expansion != null || (exp ==null && lb == null && upToExpansion == null)} => {}
)
{
    return CURRENT_NODE;
};

LookBehind : 
   [<TILDE> {CURRENT_NODE.setNegated(true);}] 
   (LookBehindForward | LookBehindBackward)
;

LookBehindForward #void :
   (
       <SLASH>
       (
         ([<TILDE>]<IDENTIFIER>)
         |
         (<DOT>|<VAR_ARGS>)
       )
   )+
   [<BACKSLASH>]
;

LookBehindBackward #void :
   (
       <BACKSLASH>
       (
          ([<TILDE>]<IDENTIFIER>)
          |
          (<DOT>|<VAR_ARGS>)
       )
   )+
   [<SLASH>]
;

INJECT LookBehind :
import java.util.*;
{
    @Property boolean negated;

    public boolean isBackward() {
        return getChild(0) instanceof Backslash || getChild(1) instanceof Backslash;
    }

    public boolean getHasFinalEllipsis() {
        Token t = (Token) getChild(getChildCount() -1);
        return t.getImage().equals("...");
    }

    public List<String> getPath() {
        ArrayList<String> result = new ArrayList<>();
        boolean negated = false;
        for (Token t : childrenOfType(Token.class)) {
            String img = t.getImage();
            if (img.charAt(0) == '\\' || img.charAt(0)=='/') continue;
            if (img.equals("~")) {
                negated = true;
                continue;
            }
            if (negated) {
                result.add("~" + img);
            } else {
               result.add(img);
            }
            negated = false;
        }
        if (result.get(0).equals("~")) {
            result.remove(0);
        }
        return result;
    }

    public boolean getHasEndingSlash() {
        Token lastToken = (Token) getChild(getChildCount()-1);
        String img = lastToken.getImage();
        return img.equals("\\") || img.equals("/");
    }

    private String routineName;
    
    public String getRoutineName() {
        if (routineName == null) {
            routineName = getGrammar().generateUniqueIdentifier("backscan$", this);
        }
        return routineName;
    }
}

Lookahead LegacyLookahead #Lookahead :
{
    Expansion expansion = null;
    Expression exp = null;
    boolean empty = true, commaAtEnd = false;
    Token t= null;
}
{
  <_LOOKAHEAD>
  [
   "(" 
      [
        t=<INTEGER_LITERAL>
        {
           CURRENT_NODE.setAmount(Integer.parseInt(t.getImage()));
           empty = false;
        }
      ]
      [ 
        SCAN {!empty} ~<RPAREN> 
        => "," {commaAtEnd = true;}
      ]
      [ 
        SCAN {empty} ~<RPAREN>|<LBRACE> 
        =>
        ["~" {CURRENT_NODE.setNegated(true);}] 
        ExpansionChoice
        {
           expansion = (Expansion) peekNode();
           empty = false; commaAtEnd = false;
           CURRENT_NODE.setNestedExpansion(expansion);
           expansion.setLookahead(CURRENT_NODE);
        }
      ]
      [ 
        SCAN {!empty && !commaAtEnd} ~")" => ","
      ]
      [
        "{"  exp=Expression  "}" {CURRENT_NODE.setSemanticLookahead(exp);}
        ["#" {CURRENT_NODE.setSemanticLookaheadNested(true);}]
      ]
     ")"
  ]
  {
     if (t == null && expansion == null && exp != null) {
         // Legacy semantics
         CURRENT_NODE.setAmount(0);
     }
     return CURRENT_NODE;
  }
}

INJECT Lookahead :
   import com.javacc.parsegen.Expansion;
   import com.javacc.parsegen.RegularExpression;
   import com.javacc.parsegen.TokenSet;
{
    @Property Expression LHS;
    @Property Expansion expansion, nestedExpansion;
    @Property boolean negated, semanticLookaheadNested;
    @Property Expression semanticLookahead;

    private int amount=Integer.MAX_VALUE;

    private boolean explicitNumerical;
    
    private Expansion upToExpansion;

    public boolean getHasExplicitNumericalAmount() {
        return explicitNumerical;
    }
    
    public boolean isAlwaysSuccessful() {
        return !hasSemanticLookahead() && (getAmount() == 0 || getLookaheadExpansion().isPossiblyEmpty()); 
    }

    public boolean getRequiresScanAhead() {
        return !getLookaheadExpansion().isPossiblyEmpty() || isSemanticLookaheadNested();
//        return !getLookaheadExpansion().isPossiblyEmpty() && getAmount() > 1;
//          return !isAlwaysSuccessful() && getAmount() >1;
    }

    public boolean hasSemanticLookahead() {
        return getSemanticLookahead() != null;
    }
    
    public Expansion getLookaheadExpansion() {
        Expansion result = getNestedExpansion();
        if (result != null) {
            return result;
        }
        return expansion;
    }


    public int getAmount() {
//        if (isSingleToken()) {
//            amount = 1;
//        }
        return amount;
    }

    public void setAmount(int amount) {
        this.amount = amount;
        this.explicitNumerical = true;
    }

    public boolean getHasExplicitAmount() {
        return amount != Integer.MAX_VALUE;
    }

    public TokenSet getFirstSet() {
        TokenSet result = new TokenSet(getGrammar());
        Expansion nestedExp = getNestedExpansion();
        if (nestedExp != null) {
            result.and(nestedExp.getFirstSet());
        }
        if (isNegated()) {
            result.not();
        }
        result.and(getExpansion().getFirstSet());
        return result;
    }
    
    private String firstSetVarName;

    public String getFirstSetVarName() {
        if (firstSetVarName == null) {
            firstSetVarName = getGrammar().generateUniqueIdentifier("first_set$", this);
        }
        return firstSetVarName;
    }

    public boolean isSingleToken() {
        return expansion.isSingleToken() && (getNestedExpansion() == null || getNestedExpansion().isSingleToken());
    }

    public LookBehind getLookBehind() {
        return firstChildOfType(LookBehind.class);
    }
              
    public Expansion getUpToExpansion() {
        return upToExpansion;
    }

    public void setUpToExpansion(Expansion upToExpansion) {
        this.upToExpansion = upToExpansion;
    }

}

Expansion ExpansionUnit :
{
    Expression lhs=null;
    Expansion result=null;
    TreeBuildingAnnotation tba = null;
}
 (
  SCAN ~\...\Lookahead => 
  result = Failure
  |
  SCAN ~\...\Lookahead =>
  result=Block ["#" {((CodeBlock)result).setAppliesInLookahead(true);}]
  |
  SCAN 1 ~\...\Lookahead =>
  result=AttemptBlock
  |
  SCAN 1 ~\...\Lookahead =>
  result=TryBlock
  |
  SCAN 1 ~\...\Lookahead =>
  result = Assertion
  |
  LexicalStateSwitch {result = (Expansion) peekNode();}
  |
  result = ExpansionWithParentheses 
  |
  result = ZeroOrOne 
  |
  SCAN [PrimaryExpression "="] (<STRING_LITERAL>|"<")
  =>
  [
    SCAN ~\...\Lookahead PrimaryExpression "=" =>
    lhs=PrimaryExpression
    "="
  ]
  RegexpExpansion
  {
      RegularExpression re = (RegularExpression) peekNode();
      result = re;
      re.setLHS(lhs);
      if (!(re instanceof EndOfFile)) {
            grammar.addInplaceRegexp(re);
      }
  }
  [SCAN ~\...\Lookahead => UpToHere(result)]
  |
  SCAN [PrimaryExpression "="]<IDENTIFIER>
  => result=NonTerminal [SCAN ~\...\Lookahead => UpToHere(result)]
 )
 [
     SCAN ~\...\Lookahead =>
     "!"
     {result.setTolerantParsing(true);}
 ]
 [
     SCAN ~\...\Lookahead => 
    tba=TreeNodeDescriptor
 ]
 {
        result.setTreeNodeBehavior(tba);
        return result;
 }
;

NonTerminal NonTerminal #NonTerminal : 
  [
    => PrimaryExpression "="
  ]
  <IDENTIFIER>
  [
    SCAN "(" ExpansionSequence "|" => {}
    |
    SCAN "(" ExpansionChoice ")" ("*"|"+"|"?") => {}
    |
    InvocationArguments
  ]
  {return CURRENT_NODE;}
;

UpToHere(Expansion exp) #void :
   <UP_TO_HERE>
   {
       String img = lastConsumedToken.getImage();
       exp.setScanLimit(true);
       char lastChar = img.charAt(img.length() -1);
       if (Character.isDigit(lastChar)) {
           exp.setScanLimitPlus(lastChar - '0');
       }
   }
;


INJECT NonTerminal : 
    import com.javacc.parsegen.*;
    import com.javacc.parsegen.TokenSet;
    extends Expansion; 
{
    /**
     * The production this non-terminal corresponds to.
     */
    
    public BNFProduction getProduction() {
        return getGrammar().getProductionByName(getName());
    }

    public InvocationArguments getArgs() {
        return firstChildOfType(InvocationArguments.class);
    }

    public Expression getLHS() {
        return firstChildOfType(Expression.class);
    }
    
    public String getName() {
        for (Node n : children) {
	    if (n instanceof Token) {
	        Token t = (Token) n;
                if (t.getType() == IDENTIFIER) {
                    return n.toString();
                }
	    }
        }
        return null;
    }
    
    /**
     * The basic logic of when we ignore an up-to-here marker
     */
    public boolean getIgnoreUpToHere() {
        if (isInsideLookahead()) return true;
        ExpansionSequence parent = (ExpansionSequence) getParent();
        if (parent.getHasExplicitNumericalLookahead() || parent.getHasScanLimit()) return true;
        for (Expansion exp : parent.getUnits()) {
            if (exp == this) return false;
            if (exp.getMaximumSize() > 0) break;
        }
        return true;
    }
    
    
     public TokenSet getFirstSet() {
        if (firstSet == null) {
//            firstSet = new TokenSet(getGrammar());
            firstSet = getProduction().getExpansion().getFirstSet();
        }
        return firstSet;
     }
     private int reEntries;     
     public TokenSet getFinalSet() {
          ++reEntries;
          TokenSet result = reEntries == 1 ? getProduction().getExpansion().getFinalSet() : new TokenSet(getGrammar());
          --reEntries;
          return result;
     }
     
     public boolean isPossiblyEmpty() {
         BNFProduction prod = this.getProduction();
         if (prod == null) {
             return false; // We already handle this case elsewhere, but REVISIT later maybe
         }
         return prod.isPossiblyEmpty();
     }
     
     // REVISIT. Why is this necessary?
     private boolean inMinimumSize, inMaximumSize;
     
     public int minimumSize(int oldMin) {
            if (inMinimumSize) {
                return Integer.MAX_VALUE;
            }
            int retval = Integer.MAX_VALUE;
            inMinimumSize = true;
            BNFProduction prod = getProduction();
            if (prod instanceof BNFProduction) {
                retval = prod.getExpansion().getMinimumSize();
            }
            inMinimumSize = false;
            return retval;
     }

     public int getMaximumSize() {
         if (inMaximumSize) {
             return Integer.MAX_VALUE;
         }
         inMaximumSize = true;
         int result = getProduction().getExpansion().getMaximumSize(); 
         inMaximumSize = false;
         return result;
     }
     
     public boolean isConcrete() {
        return getProduction().isConcrete();
     }

     public boolean getHasScanLimit() {
         return getProduction().getHasScanLimit();
     }
}

//The following two productions are not actually used. These constructs are now 
// handled by ExpansionWithParentheses so the following two productions
// are not actually used. They have to be there so that the ZeroOrMore and
// OneOrMore types get defined. REVISIT. Need a way of defining Node subtypes
// without creating a dummy grammar rule for them.
ZeroOrMore : "(" ExpansionChoice ")" "*";
OneOrMore : "(" ExpansionChoice ")" "+"; 

//This production just matches the square bracket syntax. 
// The (...)? syntax is handled by ExpansionWithParentheses
ZeroOrOne : 
    "[" ExpansionChoice "]"
     [SCAN ~\...\Lookahead => UpToHere(CURRENT_NODE)]
;

INJECT ZeroOrOne : 
     import com.javacc.parsegen.Expansion;
     import com.javacc.parsegen.TokenSet;
     extends ExpansionWithParentheses implements Expansion.ChoicePoint;
{
    public Lookahead getLookahead() {
        return getNestedExpansion().getLookahead();
    }

    public boolean isAlwaysSuccessful() {
        Lookahead la = getLookahead();
        return la == null ? getNestedExpansion().isPossiblyEmpty() : la.isAlwaysSuccessful();
    }


    public Expansion getLookaheadExpansion() {
        Lookahead la = getLookahead();
        return la == null ? this.getNestedExpansion() : la.getLookaheadExpansion();
    }
/*
    public Expansion getNestedExpansion() {
        return firstChildOfType(Expansion.class);
    }*/

    public boolean getRequiresScanAhead() {
        return getNestedExpansion().getRequiresScanAhead();
    }
    
    public boolean isPossiblyEmpty() {
        return true;
    }
/*    
    public TokenSet getFirstSet() {
        return getNestedExpansion().getFirstSet();
//        return getNestedExpansion().getLookaheadExpansion().getFirstSet();
    }
    
    public TokenSet getFinalSet() {
        return getNestedExpansion().getFinalSet();
    }*/
     
     public int minimumSize(int unused) {
         return 0;
     }
/*
     public int getMaximumSize() {
         return getNestedExpansion().getMaximumSize();
     }*/
     
     public boolean isConcrete() {return false;}
}


INJECT ZeroOrMore : 
     import com.javacc.parsegen.Expansion;
     import com.javacc.parsegen.TokenSet;
     extends ExpansionWithParentheses implements Expansion.ChoicePoint;
{
     private String id;
     public String getLabel() {
         if (id == null) {
             id = getGrammar().generateUniqueIdentifier("ZeroOrMore$", this);
         }
         return id;
     }
 
    public Lookahead getLookahead() {
        return getNestedExpansion().getLookahead();
    }

    public Expansion getLookaheadExpansion() {
        Lookahead la = getLookahead();
        return la == null ? this.getNestedExpansion() : la.getLookaheadExpansion();
    }
 
    public boolean getRequiresScanAhead() {
        return getNestedExpansion().getRequiresScanAhead();
    }

    public boolean isPossiblyEmpty() {
        return true;
    }
    
    public TokenSet getFirstSet() {
         if (firstSet == null) {
            firstSet = getNestedExpansion().getFirstSet();
//            firstSet = getNestedExpansion().getLookaheadExpansion().getFirstSet();
         }
         return firstSet;
    }
     
     public int minimumSize(int unused) {
         return 0;
     }

     public int getMaximumSize() {
         return Integer.MAX_VALUE;
     }
     
     public boolean isConcrete() {return false;}
}


INJECT OneOrMore : 
     import com.javacc.parsegen.Expansion;
     import com.javacc.parsegen.TokenSet;
     extends ExpansionWithParentheses implements Expansion.ChoicePoint;
{
     private String id;
     public String getLabel() {
         if (id == null) {
             id = getGrammar().generateUniqueIdentifier("OneOrMore$", this);
         }
         return id;
     }
     
    public Lookahead getLookahead() {
        return getNestedExpansion().getLookahead();
    }
    
    public Expansion getLookaheadExpansion() {
        Lookahead la = getLookahead();
        return la == null ? this.getNestedExpansion() : la.getLookaheadExpansion();
    }
    
    public boolean getRequiresScanAhead(){
        Lookahead la = getLookahead();
        if (la != null) {
           return la.getRequiresScanAhead();
        }
        return getNestedExpansion().getRequiresScanAhead();
    }
     
     public int getMaximumSize() {
         return Integer.MAX_VALUE;
     }
 
     public boolean isConcrete() {return false;}
}


AttemptBlock AttemptBlock : 
{
  boolean hasRecoverExpansion = false;
}
{
 "ATTEMPT"
 "(" ExpansionChoice ")"
 "RECOVER"
 (Block  | "(" ExpansionChoice {hasRecoverExpansion = true;} ")")
 [
    SCAN {!hasRecoverExpansion} "("
    => "(" ExpansionChoice ")"  
 ]
 {
     return CURRENT_NODE;
 }
}

INJECT AttemptBlock : 
   import java.util.List;
   import com.javacc.parsegen.Expansion;
   import com.javacc.parsegen.TokenSet;
   extends Expansion;
{
   public Expansion getNestedExpansion() {
       return firstChildOfType(Expansion.class);
   }
   
   public Expansion getRecoveryExpansion() {
        List<Expansion> expansions = childrenOfType(Expansion.class);
        if (getRecoveryCode() == null) {
            return expansions.get(1);
        }
        return expansions.size() > 2 ? expansions.get(2) : null;
   }
   
   public CodeBlock getRecoveryCode() {
        return firstChildOfType(CodeBlock.class); 
   }
   
   
    public boolean isPossiblyEmpty() {
        return getNestedExpansion().isPossiblyEmpty();
    }
    
    //REVISIT: Should this take RECOVER into account? I don't think so,
    // but I still have to think about it a bit more.
    public TokenSet getFirstSet() {
        if (firstSet == null) {
           firstSet=getNestedExpansion().getFirstSet();
        }
        return firstSet;
    }
   
   
    //REVISIT: Should this take RECOVER into account? 
    public TokenSet getFinalSet() {
        return getNestedExpansion().getFinalSet();
    }
     
     public int minimumSize(int min) {
           return getNestedExpansion().getMinimumSize();
     }

     public int getMaximumSize() {
         return getNestedExpansion().getMaximumSize();
     }
     
     public boolean isConcrete() {
           return getNestedExpansion().isConcrete();
     }
}

Failure Failure : 
   {Token t;}
   t="FAIL"
   [
      t=<STRING_LITERAL>
      |
      Block
   ]
   {
       String message = "Failure: ";
       message += removeEscapesAndQuotes(t);
       CURRENT_NODE.setMessage(message);
       return CURRENT_NODE;
   }
;



INJECT Failure :
   import com.javacc.parsegen.TokenSet;
   extends com.javacc.parsegen.Expansion
{
    @Property String message;
    public CodeBlock getCode() {
        return firstChildOfType(CodeBlock.class);
    }

    public boolean isConcrete() {return true;}
    
    public int getMaximumSize() {return 0;}

    public int minimumSize(int min) {return 0;}

    public boolean isPossiblyEmpty() {return true;}
    
    public TokenSet getFirstSet() {return new TokenSet(getGrammar());}

    public TokenSet getFinalSet() {return new TokenSet(getGrammar());}

    public boolean isAlwaysSuccessful() {return false;}
}

LexicalStateSwitch : "LEXICAL_STATE" <IDENTIFIER>;

INJECT LexicalStateSwitch : 
   import com.javacc.parsegen.TokenSet;
   extends com.javacc.parsegen.Expansion
{
    public boolean isConcrete() {return true;}
    
    public int getMaximumSize() {return 0;}

    public int minimumSize(int min) {return 0;}

    public boolean isPossiblyEmpty() {return true;}
    
    public TokenSet getFirstSet() {return new TokenSet(getGrammar());}

    public TokenSet getFinalSet() {return new TokenSet(getGrammar());}

    public String getLexicalStateName() {return firstChildOfType(Identifier.class).getNormalizedText();}

    public boolean isAlwaysSuccessful() {return true;}
}


TryBlock TryBlock : 
    "try" "{" ExpansionChoice "}"
    (
        CatchBlock
    )*
    [
        FinallyBlock
    ]
    {
       return CURRENT_NODE;
    }
;

INJECT TryBlock  : 
    import java.util.List;
    import com.javacc.parsegen.TokenSet;
    import com.javacc.parsegen.Expansion;
    extends Expansion;
{
    public Expansion getNestedExpansion() {
        return firstChildOfType(Expansion.class);
    }
    
    public List<CatchBlock> getCatchBlocks() {
        return childrenOfType(CatchBlock.class);
    }

    public FinallyBlock getFinallyBlock() {
        return firstChildOfType(FinallyBlock.class);
    }
    
    public boolean isPossiblyEmpty() {
        return getNestedExpansion().isPossiblyEmpty();
    }
    
    public TokenSet getFirstSet() {
        return getNestedExpansion().getFirstSet();
    }
    
    public TokenSet getFinalSet() {
        return getNestedExpansion().getFinalSet();
    }
     
     public int minimumSize(int min) {
           return getNestedExpansion().getMinimumSize();
     }

     public int getMaximumSize() {
         return getNestedExpansion().getMaximumSize();
     }
    @Property boolean appliesInLookahead;
     
     public boolean isConcrete() {
          return getNestedExpansion().isConcrete();
     }
}


INJECT CodeBlock :
   import com.javacc.parsegen.TokenSet;
   extends com.javacc.parsegen.Expansion;
{
    @Property boolean appliesInLookahead;

    public CodeBlock getJavaCode() {
        return this;
    }
    
    public boolean isPossiblyEmpty() {
       return true;
    }
    
    /**
     * These are here to fullfil the superclass contract. They are never used. 
     */

    public TokenSet getFirstSet() {return new TokenSet(getGrammar());}

    public TokenSet getFinalSet() {return new TokenSet(getGrammar());}
    
    public int minimumSize(int unused) {
        return 0;
    }

    public int getMaximumSize() {
        return 0;
    }
    
    public boolean isConcrete() {
        return true; //REVISIT.
    }

}

RegexpExpansion #void :
 (
  RegexpStringLiteral 
  |
  SCAN ~\.\TokenProduction =>
  (RegexpRef|EndOfFile)
  |
  SCAN 3 {isInProduction("TokenProduction")||grammar.getUserDefinedLexer()} =>
  InPlaceRegexp 
 ) 
;


InPlaceRegexp #void :
{
    RegularExpression re, choice;
    String image = "";
    Token t;
    boolean isPrivate= false;
}
  t=<LT>
  [
   (
     t=<IDENTIFIER> {image = t.getImage();}
     |
     SCAN ~\...\BNFProduction 
     => "#"t=<IDENTIFIER> {image = t.getImage(); isPrivate= true;}
   )
   ":"
  ]
  {clearNodeScope();}
  RegexpChoice {choice = (RegularExpression) peekNode();} 
  <GT>
  {
	  if (choice instanceof RegexpRef) {
	    RegexpSequence seq = new RegexpSequence();
	    seq.addChild(choice);
	    re = seq;
	  } else {
	    re = choice;
	  }
	  if (image.length() ==0 && isInProduction("BNFProduction")) {
	     grammar.addParseError(t, "It is mandatory to label an inline regexp in a grammar production.");
	  }
	  re.setLabel(image);
	  re.setGeneratedClassName(image);
	  re.setPrivate(isPrivate); 
	  re.setBeginLine(t.getBeginLine());
	  re.setBeginColumn(t.getBeginColumn());
	  pokeNode(re);
  }
;

RegexpStringLiteral RegexpStringLiteral #RegexpStringLiteral :
   <STRING_LITERAL>
   {
      String image = removeEscapesAndQuotes(lastConsumedToken);
      CURRENT_NODE.setImage(image);
      return CURRENT_NODE;
   }
;

INJECT RegexpStringLiteral : 
   import com.javacc.lexgen.*;
   import com.javacc.parsegen.RegularExpression;
   extends RegularExpression;
{
  @Property String image;
  

  public String toString() {
    return super.toString() + " - " + getImage();
  }
  
  //REVISIT What about different lexical states? As well as ignoreCase... 
  public boolean equals(Object obj) {
      return obj instanceof RegexpStringLiteral && ((RegexpStringLiteral) obj).image == this.image;
  }
  
  public int hashCode() {
      return image.hashCode();
  }

  public boolean matchesEmptyString() {
      return getImage().length() == 0;
  }
}

RegexpRef RegexpRef : 
{
   Token t;
}
    "<"
    t=<IDENTIFIER> =>||
    ">" 
    {
       CURRENT_NODE.setLabel(t.getImage());
       return CURRENT_NODE;
    }
;

INJECT RegexpRef : 
    import com.javacc.lexgen.*;
    import com.javacc.parsegen.RegularExpression;
    extends RegularExpression;
{
    @Property RegularExpression regexp;

    public boolean isPrivate() {
        return regexp!= null && regexp.isPrivate(); //REVISIT, why do we need a null check?
    }

    public boolean matchesEmptyString() {
        return regexp != null && regexp.matchesEmptyString();
    }
}

EndOfFile : "<" <_EOF> =>|| ">" ;

INJECT EndOfFile : extends com.javacc.parsegen.RegularExpression
{
    public boolean matchesEmptyString() {return true;}
}

RegexpChoice :
    RegexpSequence 
    ("|" RegexpSequence)*
;

RegexpChoiceInParen #RegexpChoice : 
   "(" RegexpSequence() ("|" RegexpSequence())* ")"
;

INJECT RegexpChoice : 
    import java.util.List;
    import com.javacc.parsegen.RegularExpression;
    extends RegularExpression;
{
    public List<RegularExpression> getChoices() {
        return childrenOfType(RegularExpression.class);
    }

    public boolean matchesEmptyString() {
        for (RegularExpression choice: getChoices()) {
            if (choice.matchesEmptyString()) {
                return true;
            }
        }
        return false;
    }
}

RegexpSequence :
   (
	  RegexpStringLiteral
	  |
	  RegexpRef
	  |
	  CharacterList
	  |
	  RepeatedRegexp
   )+
;

INJECT RegexpSequence : 
   import java.util.*;
   import com.javacc.parsegen.RegularExpression;
   extends RegularExpression;
{
   public List<RegularExpression> getUnits() {
       return childrenOfType(RegularExpression.class);
   }

   public boolean matchesEmptyString() {
       for (RegularExpression child : getUnits()) {
           if (!child.matchesEmptyString()) return false;
       }
       return true;
   }
}

RepeatedRegexp #void : 
{
     int r1 = 0, r2 = -1;
     Token t;
     boolean hasMax = false;
}
  RegexpChoiceInParen
  (  "+" #OneOrMoreRegexp(2) 
   | "*" #ZeroOrMoreRegexp(2)
   | "?" #ZeroOrOneRegexp(2) 
   | "{" t  = <INTEGER_LITERAL> {r1 = ((IntegerLiteral)t).getValue();}
         [ "," { hasMax = true; } [ t = <INTEGER_LITERAL> {r2=((IntegerLiteral)t).getValue();} ] ]
     "}" #RepetitionRange(4 + (hasMax ? 1 : 0) + (r2!=-1 ? 1 : 0))
     {
         RepetitionRange range = (RepetitionRange) peekNode();
         range.setMin(r1);
         range.setMax(r2);
     }
  )?
;

INJECT RepetitionRange : 
   import com.javacc.parsegen.RegularExpression;
   extends RegularExpression;
{
    @Property int min = 0, max = -1;


    public boolean hasMax() {
        for (Node n : children) {
	   if (n instanceof Token) {
	       Token t = (Token) n;
               if (t.getType() == COMMA) return true;	       
	   }

        }
        return false;
    }
    
    public RegularExpression getRegexp() { 
        return firstChildOfType(RegularExpression.class);
    }

    public boolean matchesEmptyString() {
        if (min ==0) return true;
        return getRegexp().matchesEmptyString();
    }
}

INJECT OneOrMoreRegexp : 
   import com.javacc.parsegen.RegularExpression;
   extends RegularExpression;
{
   public RegularExpression getRegexp() 
   {
      return firstChildOfType(RegularExpression.class);
   }

   public boolean matchesEmptyString() {
       return getRegexp().matchesEmptyString(); 
   }
}

INJECT ZeroOrMoreRegexp : 
   import com.javacc.parsegen.RegularExpression;
   extends RegularExpression;
{
   public RegularExpression getRegexp() 
   {
      return firstChildOfType(RegularExpression.class);
   }
   
   public void setRegexp(RegularExpression regexp) {
      RegularExpression current = getRegexp();
      if (current != null) {
          addChild(indexOf(current), regexp);
          removeChild(current);
      } else {
          addChild(0, regexp);
      }
   }

   public boolean matchesEmptyString() {
       return true;
   }
}

INJECT ZeroOrOneRegexp : 
   import com.javacc.parsegen.RegularExpression;
   extends RegularExpression;
{
   public RegularExpression getRegexp() 
   {
      return firstChildOfType(RegularExpression.class);
   }
   
   public void setRegexp(RegularExpression regexp) {
      RegularExpression current = getRegexp();
      if (current != null) {
          addChild(indexOf(current), regexp);
          removeChild(current);
      } else {
          addChild(0, regexp);
      }
   }

   public boolean matchesEmptyString() {
       return true;
   }
}

CharacterList CharacterList :
  ["~"]
  "[" [CharacterRange
        ( "," CharacterRange)*
      ]
  "]"
   {
      return CURRENT_NODE;
   }
;

INJECT CharacterList : 
   import java.util.*;
   import com.javacc.lexgen.*;
   import com.javacc.parsegen.RegularExpression;
   extends RegularExpression;
{
    public List<CharacterRange> getDescriptors() {
        return childrenOfType(CharacterRange.class);
    }

    public boolean isNegated() {
        for (Node n : children) {
	    if (n instanceof Token) {
	       Token t = (Token) n;
               if (t.getType() == TILDE) {
                  return true;
               }
	       }
        }
        return false;
    }

public boolean matchesEmptyString() {
        return false;
    }
}

CharacterRange CharacterRange #CharacterRange :
{
      Token imageL, imageR;
}
  imageL=<STRING_LITERAL>
        {
          String lString = removeEscapesAndQuotes(imageL);
          CURRENT_NODE.left = character_descriptor_assign(lastConsumedToken, lString);
          CURRENT_NODE.right = CURRENT_NODE.left;
        }
   [
   "-"
    imageR=<STRING_LITERAL>
        {
          String rString = removeEscapesAndQuotes(imageR);
          CURRENT_NODE.right = character_descriptor_assign(lastConsumedToken, rString, lString);
        }
   ]
   {return CURRENT_NODE;}
;

INJECT CharacterRange :
{
    public char left, right;
    
    public CharacterRange() {}
    
    public CharacterRange(char left, char right) {
        setRange(left, right);
    }
    
    public void setRange(char left, char right) {
        if (left > right) {
            throw new ArrayIndexOutOfBoundsException();
        }
        this.left = left;
        this.right = right;
    }

    public boolean isSingleChar() {
       return left == right;
    }
}