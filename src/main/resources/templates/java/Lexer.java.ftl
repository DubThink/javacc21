[#--
/* Copyright (c) 2008-2020 Jonathan Revusky, revusky@javacc.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notices,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary formnt must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name Jonathan Revusky, Sun Microsystems, Inc.
 *       nor the names of any contributors may be used to endorse
 *       or promote products derived from this software without specific prior written
 *       permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
 --]
 /* Generated by: ${generated_by}. ${filename} */
 [#var options=grammar.options, lexerData=grammar.lexerData]
 [#var tokenBuilderClass = options.hugeFileSupport?string("TokenBuilder", "FileLineMap")]
 [#var numLexicalStates=lexerData.lexicalStates?size]

  [#if grammar.parserPackage?has_content]
    package ${grammar.parserPackage};
  [/#if]
[#if grammar.options.userDefinedLexer]
  [#embed "LexerInterface.java.ftl"]
[#else]
[#list grammar.parserCodeImports as import]
   ${import}
[/#list]

import java.io.Reader;
import java.io.IOException;
import java.util.logging.Logger;
import java.util.*;

@SuppressWarnings("unused")
public class ${grammar.lexerClassName} implements ${grammar.constantsClassName} {
private static final Logger LOGGER = Logger.getLogger("${grammar.parserClassName}");
    [#if grammar.options.debugLexer]  
  private boolean trace_enabled = true;
    [#else]  
  private boolean trace_enabled = false;
    [/#if]
  
  private void setTracingEnabled(boolean trace_enabled) {
     this.trace_enabled = trace_enabled;
  }
  
  public String getInputSource() {
      return inputSource;
  }
  
  public void setInputSource(String inputSource) {
      this.inputSource = inputSource;
[#if !grammar.options.hugeFileSupport]
      input_stream.setInputSource(inputSource);
[/#if]            
  }
   
[#if !options.hugeFileSupport]
     public ${grammar.lexerClassName}(String inputSource, CharSequence chars) {
        this(inputSource, chars, LexicalState.${lexerData.lexicalStates[0].name}, 1, 1);
     }
     public ${grammar.lexerClassName}(String inputSource, CharSequence chars, LexicalState lexState, int line, int column) {
        input_stream = new ${tokenBuilderClass}(inputSource, chars, line, column);
        switchTo(lexState);
     }
     [#if options.legacyAPI]
         public ${grammar.lexerClassName}(String inputSource, CharSequence chars, int lexState, int line, int column) {
            this(inputSource, chars, LexicalState.values()[lexState],  line, column);
         }
     [/#if]
[/#if]
    public ${grammar.lexerClassName}(Reader reader) {
       this(reader, LexicalState.${lexerData.lexicalStates[0].name}, 1, 1);
    }
    public ${grammar.lexerClassName}(Reader reader, LexicalState lexState, int line, int column) {
        input_stream = new ${tokenBuilderClass}(reader, line, column);
        switchTo(lexState);
    }
[#if options.legacyAPI]
         public ${grammar.lexerClassName}(Reader reader, int lexState, int line, int column) {
            this(reader, LexicalState.values()[lexState],  line, column);
         }
[/#if]

${tokenBuilderClass} input_stream;

public final void backup(int amount) {
    input_stream.backup(amount);
}

  LexicalState lexicalState = LexicalState.${lexerData.lexicalStates[0].name};
 
[#if numLexicalStates>1]
   boolean doLexicalStateSwitch(int tokenType) {
       LexicalState newLexState = newLexicalStates[tokenType];
       if (newLexState != null) {
           return switchTo(newLexState);
       }
       return false;
   }
   
   boolean doLexicalStateSwitch(TokenType tokenType) {
       return doLexicalStateSwitch(tokenType.ordinal());
   }
  
  private static final LexicalState[] newLexicalStates = {
         [#list lexerData.regularExpressions as regexp]
             [#if regexp.newLexicalState?is_null]
                null,
             [#else]
                LexicalState.${regexp.newLexicalState.name},
             [/#if]
          [/#list]
  };
[/#if]
  

void addToken(Token token) {
    [#if !options.hugeFileSupport]
       input_stream.addToken(token);
    [/#if]  
}  
    int tabSize = 8;
 [#if options.lexerUsesParser]

  public ${grammar.parserClassName} parser;
[/#if]

    /** Switch to specified lexical state. */
    public boolean switchTo(LexicalState lexState) {
        if (this.lexicalState != lexState) {
           if (trace_enabled) LOGGER.info("Switching from lexical state " + this.lexicalState + " to " + lexState);
           this.lexicalState = lexState;
           return true;
        }
        return false;
    }
[#if grammar.options.legacyAPI]
    /**
      * @deprecated Use the switchTo method that takes an Enum
      */
    @Deprecated
    public boolean SwitchTo(int lexState) {
       return switchTo(LexicalState.values()[lexState]);
    }
    
    @Deprecated
    public void setTabSize(int  size) {this.tabSize=tabSize;}
[/#if]

  private InvalidToken invalidToken; 
  private Token pendingToken;
  
  public Token getNextToken() {
      if (pendingToken != null) {
          Token result = pendingToken;
          pendingToken = null;
          return result;
      }
      Token tok = null;
      do {
         tok = nextToken();
      }  while (tok instanceof InvalidToken);
      if (invalidToken != null) {
          addToken(invalidToken);
          invalidToken.setNext(tok);
          Token it = invalidToken;
          pendingToken = tok;
          this.invalidToken = null;
          return it;
      }
      addToken(tok);
      return tok;
 }


 [#if options.hugeFileSupport]
    [#embed "LegacyTokenBuilder.java.ftl"]
 [#else]
        // Reset the token source input
    // to just after the Token passed in.
    void reset(Token t) {
        input_stream.goTo(t.getEndLine(), t.getEndColumn());
        input_stream.forward(1);
    }
    
    FileLineMap getFileLineMap() {
        return input_stream;
    }

 [/#if]
    [#embed "LexerCode.java.ftl"] 
}
[/#if]
