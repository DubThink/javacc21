[#--
/* Copyright (c) 2008-2020 Jonathan Revusky, revusky@javacc.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notices,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary formnt must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name Jonathan Revusky, Sun Microsystems, Inc.
 *       nor the names of any contributors may be used to endorse
 *       or promote products derived from this software without specific prior written
 *       permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
 --]
 /* Generated by: ${generated_by}. ${filename} */
 [#var options=grammar.options, lexerData=grammar.lexerData]
 [#var tokenBuilderClass = options.hugeFileSupport?string("TokenBuilder", "FileLineMap")]
 [#var numLexicalStates=lexerData.lexicalStates?size]

[#if grammar.parserPackage?has_content]
    package ${grammar.parserPackage};
    import static ${grammar.parserPackage}.${grammar.constantsClassName}.TokenType.*;
[/#if]
[#if grammar.options.userDefinedLexer]
  [#embed "LexerInterface.java.ftl"]
[#else]
[#list grammar.parserCodeImports as import]
   ${import}
[/#list]

import java.io.Reader;
import java.io.IOException;
import java.util.logging.Logger;
import java.util.*;

@SuppressWarnings("unused")
public class ${grammar.lexerClassName} implements ${grammar.constantsClassName} {
private static final Logger LOGGER = Logger.getLogger("${grammar.parserClassName}");
    [#if grammar.options.debugLexer]  
  private boolean trace_enabled = true;
    [#else]  
  private boolean trace_enabled = false;
    [/#if]
  
  private void setTracingEnabled(boolean trace_enabled) {
     this.trace_enabled = trace_enabled;
  }
  
  public String getInputSource() {
      return inputSource;
  }
  
  public void setInputSource(String inputSource) {
      this.inputSource = inputSource;
[#if !grammar.options.hugeFileSupport]
      input_stream.setInputSource(inputSource);
[/#if]            
  }
   
[#if !options.hugeFileSupport]
     public ${grammar.lexerClassName}(String inputSource, CharSequence chars) {
        this(inputSource, chars, LexicalState.${lexerData.lexicalStates[0].name}, 1, 1);
     }
     public ${grammar.lexerClassName}(String inputSource, CharSequence chars, LexicalState lexState, int line, int column) {
        input_stream = new ${tokenBuilderClass}(inputSource, chars, line, column);
        switchTo(lexState);
     }
[/#if]
    public ${grammar.lexerClassName}(String inputSource, Reader reader) {
       this(inputSource, reader, LexicalState.${lexerData.lexicalStates[0].name}, 1, 1);
    }
    /**
     * @deprecated Use the constructor where you specify an inputSource string so that you can have error messages that make sense!
     */
    @Deprecated
    public ${grammar.lexerClassName}(Reader reader) {
        this("input" , reader);
    }
    public ${grammar.lexerClassName}(String inputSource, Reader reader, LexicalState lexState, int line, int column) {
        input_stream = new ${tokenBuilderClass}(inputSource, reader, line, column);
        switchTo(lexState);
    }
    
${tokenBuilderClass} input_stream;

public final void backup(int amount) {
    input_stream.backup(amount);
}

  LexicalState lexicalState = LexicalState.${lexerData.lexicalStates[0].name};
 
[#if numLexicalStates>1]
   boolean doLexicalStateSwitch(int tokenType) {
       LexicalState newLexState = newLexicalStates[tokenType];
       if (newLexState != null) {
           return switchTo(newLexState);
       }
       return false;
   }
   
   boolean doLexicalStateSwitch(TokenType tokenType) {
       return doLexicalStateSwitch(tokenType.ordinal());
   }
  
  private static final LexicalState[] newLexicalStates = {
         [#list lexerData.regularExpressions as regexp]
             [#if regexp.newLexicalState?is_null]
                null,
             [#else]
                LexicalState.${regexp.newLexicalState.name},
             [/#if]
          [/#list]
  };
[/#if]
  
    int tabSize = 8;
 [#if options.lexerUsesParser]

  public ${grammar.parserClassName} parser;
[/#if]

    /** Switch to specified lexical state. */
    public boolean switchTo(LexicalState lexState) {
        if (this.lexicalState != lexState) {
           if (trace_enabled) LOGGER.info("Switching from lexical state " + this.lexicalState + " to " + lexState);
           this.lexicalState = lexState;
           return true;
        }
        return false;
    }
[#if grammar.options.legacyAPI]
    /**
      * @deprecated Use the switchTo method that takes an Enum
      */
    @Deprecated
    public boolean SwitchTo(int lexState) {
       return switchTo(LexicalState.values()[lexState]);
    }
    
    @Deprecated
    public void setTabSize(int  size) {this.tabSize=tabSize;}
[/#if]

  private InvalidToken invalidToken;
  private Token previousToken; 
  
  public Token getNextToken() {
      Token tok = null;
      do {
          tok = nextToken();
      } while (tok instanceof InvalidToken);
      if (invalidToken != null) {
          invalidToken.setNextToken(tok);
          tok.setPreviousToken(invalidToken);
          Token it = invalidToken;
          this.invalidToken = null;
          return it;
      }
      tok.setPreviousToken(previousToken);
      if (previousToken != null) previousToken.setNextToken(tok);
      return previousToken = tok;
 }

[#if grammar.productionTable?size != 0]
    static public String addEscapes(String s) {
        return ParseException.addEscapes(s);
    }
[#else]
    static public String addEscapes(String str) {
        StringBuilder retval= new StringBuilder();
        char ch;
        for (int i= 0; i<str.length(); i++) {
            switch(str.charAt(i)) {
                case 0:
                continue;
                case'\b':
                retval.append("\\b");
                continue;
                case'\t':
                retval.append("\\t");
                continue;
                case'\n':
                retval.append("\\n");
                continue;
                case'\f':
                retval.append("\\f");
                continue;
                case'\r':
                retval.append("\\r");
                continue;
                case'\"':
                retval.append("\\\"");
                continue;
                case'\'':
                retval.append("\\\'");
                continue;
                case'\\':
                retval.append("\\\\");
                continue;
                default:
                if ((ch= str.charAt(i))<0x20||ch> 0x7e) {
                    String s= "0000"+java.lang.Integer.toString(ch, 16);
                    retval.append("\\u"+s.substring(s.length()-4, s.length()));
                }
                else {
                    retval.append(ch);
                }
                continue;
            }
        }
        return retval.toString();
    }
[/#if]


 [#if options.hugeFileSupport]
    [#embed "LegacyTokenBuilder.java.ftl"]
 [#else]
        // Reset the token source input
    // to just after the Token passed in.
    void reset(Token t, LexicalState state) {
        input_stream.goTo(t.getEndLine(), t.getEndColumn());
        input_stream.forward(1);
        t.setNext(null);
        if (state != null) {
            switchTo(state);
        }
    }

    void reset(Token t) {
        reset(t, null);
    }

    
    FileLineMap getFileLineMap() {
        return input_stream;
    }

 [/#if]
    [#embed "LexerCode.java.ftl"] 
}
[/#if]
