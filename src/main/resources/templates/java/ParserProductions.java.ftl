[#ftl strict_vars=true]
[#--
/* Copyright (c) 2008-2020 Jonathan Revusky, revusky@javacc.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notices,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name Jonathan Revusky, Sun Microsystems, Inc.
 *       nor the names of any contributors may be used to endorse 
 *       or promote products derived from this software without specific prior written 
 *       permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
 --]

[#macro Generate]
     [@Productions/]
    [@firstSetVars/]
    [#if grammar.options.faultTolerant]
    [@finalSetVars/]
    [@followSetVars/]  
    [/#if]
    [#if parserData.scanAheadExpansions?size !=0]
       [@BuildLookaheads /]
     [/#if]
[/#macro]
 
[#macro Productions] 
 //=================================
 // Start of methods for BNF Productions
 //This code is generated by the ParserProductions.java.ftl template. 
 //=================================
  [#list grammar.parserProductions as production]
    [#set currentProduction = production]
    [@ParserProduction production/]
  [/#list]
[/#macro]

[#macro BuildLookaheads]
  private Token currentLookaheadToken;
  private int remainingLookahead;
  private boolean semanticLookahead; 
  private final boolean scanToken(TokenType type) {
       if (remainingLookahead <=0) return true;
       if (currentLookaheadToken.getNext() == null) {
        Token nextToken = token_source.getNextToken();
        currentLookaheadToken.setNext(nextToken);
     } 
     currentLookaheadToken = currentLookaheadToken.getNext();
     if (currentLookaheadToken.getType() != type) return false;
     --remainingLookahead;
     return true;
  }
//====================================
 // Lookahead Routines
 //====================================
   [#list parserData.scanAheadExpansions as expansion]
        [@buildScanRoutine expansion, expansion.maxScanAhead /]
   [/#list]
[/#macro]   

[#macro firstSetVars]
    //=================================
     // EnumSets that represent the various expansions' first set (i.e. the set of tokens with which the expansion can begin)
     //=================================
    [#list grammar.expansionsForFirstSet as expansion]
          [@firstSetVar expansion/]
    [/#list]
[/#macro]

[#macro finalSetVars]
    //=================================
     // EnumSets that represent the various expansions' final set (i.e. the set of tokens with which the expansion can end)
     //=================================
    [#list grammar.expansionsForFinalSet as expansion]
          [@finalSetVar expansion/]
    [/#list]
[/#macro]


[#macro followSetVars]
    //=================================
     // EnumSets that represent the various expansions' follow set (i.e. the set of tokens that can immediately follow this)
     //=================================
    [#list grammar.expansionsForFollowSet as expansion]
          [@followSetVar expansion/]
    [/#list]
[/#macro]

[#macro firstSetVar expansion]
    [@enumSet expansion.firstSetVarName expansion.firstSetTokenNames /]
[/#macro]

[#macro finalSetVar expansion]
    [@enumSet expansion.finalSetVarName expansion.finalSetTokenNames /]
[/#macro]            

[#macro followSetVar expansion]
    [@enumSet expansion.followSetVarName expansion.followSetTokenNames/]
[/#macro]            

[#macro enumSet varName tokenNames]
   [#if tokenNames?size=0]
       static private final EnumSet<TokenType> ${varName} = EnumSet.noneOf(TokenType.class);
   [#else]
       static private final EnumSet<TokenType> ${varName} = EnumSet.of(
       [#list tokenNames as type]
          [#if type_index > 0],[/#if]
          TokenType.${type} 
       [/#list]
     );
   [/#if]
[/#macro]

[#macro ParserProduction production]

    [@firstSetVar production.expansion/]
    [#if grammar.options.faultTolerant]
      [@finalSetVar production.expansion/]
    [/#if]
    ${production.leadingComments}
// ${production.inputSource}, line ${production.beginLine}
    final ${production.accessMod!"public"} 
    ${production.returnType!"void"}
    ${production.name}(${production.parameterList!}) 
    throws ParseException
    [#list (production.throwsList.types)! as throw], ${throw}[/#list] {
     if (trace_enabled) LOGGER.info("Entering production defined on line ${production.beginLine} of ${production.inputSource}");
     if (cancelled) throw new CancellationException();
   [@BuildCode production.expansion /]
    }   
[/#macro]

[#macro BuildCode expansion]
   [#if expansion.simpleName != "ExpansionSequence"]
  // Code for ${expansion.simpleName} specified on line ${expansion.beginLine} of ${expansion.inputSource}
  [/#if]
    [#var forced=expansion.forced, nodeVarName, parseExceptionVar, production, treeNodeBehavior, buildTreeNode=false, forcedVarName, closeCondition = "true", callStackSizeVar]
    [#set treeNodeBehavior = expansion.treeNodeBehavior]
    [#if expansion.parent.simpleName = "BNFProduction"]
      [#set production = expansion.parent]
      [#set forced = production.forced || forced]
    [/#if]
    [#if grammar.options.treeBuildingEnabled]
      [#set buildTreeNode = (treeNodeBehavior?is_null && production?? && !grammar.options.nodeDefaultVoid)
                        || (treeNodeBehavior?? && !treeNodeBehavior.void)]
    [/#if]
    [#if buildTreeNode]
        [@setupTreeVariables .scope /]
        [#if grammar.options.faultTolerant]
         [#if forced]
              boolean ${forcedVarName} = this.tolerantParsing;
          [#else]
              boolean ${forcedVarName} = this.tolerantParsing && currentNTForced;
          [/#if]
        [#else]
        boolean ${forcedVarName} = false;
        [/#if]
   	[@createNode treeNodeBehavior nodeVarName /]
          ParseException ${parseExceptionVar} = null;
          [#set newVarIndex = newVarIndex +1]
          [#set callStackSizeVar = "callStackSize" + newVarIndex]
          int ${callStackSizeVar} = callStack.size();
         try {
    [/#if]
        ${(production.javaCode)!}
        [@BuildExpansionCode expansion/]
    [#var returnType = (production.returnType)!"void"]
    [#if production?? && returnType == "void"]
        if (trace_enabled) LOGGER.info("Exiting normally from ${production.name}");
    [/#if]
    [#if buildTreeNode]
         }
         catch (ParseException e) { 
             ${parseExceptionVar} = e;
      [#if !grammar.options.faultTolerant]
             throw e;
      [#else]             
             if (trace_enabled) LOGGER.info("We have a parse error but are in in fault-tolerant mode, so we try to handle it.");
	       [#if production?? && returnType == production.nodeName]
	          [#-- We just assume that if the return type is the same as the type of the node, we want to return CURRENT_NODE.
	                This is not theoretically correct, but will probably be true about 99% of the time. Maybe REVISIT. --]
	           return ${nodeVarName};
	       
	          [#-- This is a bit screwy will not work if the return type is a primitive type --]
	           return null;
	       [/#if]
[/#if]	
         }
         finally {
             if (${parseExceptionVar} == null) {
                restoreCallStack(${callStackSizeVar});
             }
[#if !grammar.options.faultTolerant]
             if (buildTree) {
                 if (${parseExceptionVar} == null) {
                     closeNodeScope(${nodeVarName}, ${closeCondition});
                 } else {
                     if (trace_enabled) LOGGER.warning("ParseException: " + ${parseExceptionVar}.getMessage());
                     clearNodeScope();
                 }
             }
[#else]
             if (buildTree) {
                 if (${parseExceptionVar} == null) {
 	                 closeNodeScope(${nodeVarName}, ${closeCondition});
                 }
	             else {
                     if (trace_enabled) LOGGER.warning("ParseException ${parseExceptionVar}: " + ${parseExceptionVar}.getMessage());
	                 ${nodeVarName}.setParseException(${parseExceptionVar});
                     if (${forcedVarName}) { 
                        restoreCallStack(${callStackSizeVar});
                        Token virtualToken = insertVirtualToken(TokenType.${expansion.finalSet.firstTokenName}); 
                        resetNextToken();
                        if (tokensAreNodes) {
                            currentNodeScope.add(virtualToken);
                        } 
                        String message = "Inserted virtual token of type " + virtualToken.getType()
                                                  +"\non line " + virtualToken.getBeginLine()
                                                  + ", column " + virtualToken.getBeginColumn()
                                                   + " of " + token_source.getInputSource()
                                                  +"\n to complete expansion in ${currentProduction.name}\n";
                        message += ${parseExceptionVar}.getMessage(); 
                        addParsingProblem(new ParsingProblem(message, ${nodeVarName})); 
		                closeNodeScope(${nodeVarName}, true); 
		             } else {
                        closeNodeScope(${nodeVarName}, false);
                        if (trace_enabled) LOGGER.info("Rethrowing " + "${parseExceptionVar}");
		                throw ${parseExceptionVar};
		             }
	             }
        }
[/#if]  
         }       
          ${grammar.utils.popNodeVariableName()!}
    [/#if]
[/#macro]

[#--  A helper macro to set up some variables so that the BuildCode macro can be a bit more readable --]
[#macro setupTreeVariables callingScope]
    [#set nodeNumbering = nodeNumbering +1]
    [#set nodeVarName = currentProduction.name + nodeNumbering in callingScope]
    [#set forcedVarName = callingScope.nodeVarName+"forced" in callingScope]
    ${grammar.utils.pushNodeVariableName(callingScope.nodeVarName)!}
    [#set parseExceptionVar = "parseException"+nodeNumbering in callingScope]
    [#if !callingScope.treeNodeBehavior??]
        [#if grammar.options.smartNodeCreation]
           [#set treeNodeBehavior = {"name" : callingScope.production.name, "condition" : "1", "gtNode" : true, "void" :false} in callingScope]
        [#else]
           [#set treeNodeBehavior = {"name" : callingScope.production.name, "condition" : null, "gtNode" : false, "void" : false} in callingScope]
        [/#if]
     [/#if]
     [#if callingScope.treeNodeBehavior.condition?has_content]
       [#set closeCondition = callingScope.treeNodeBehavior.condition in callingScope]
       [#if callingScope.treeNodeBehavior.gtNode]
          [#set closeCondition = "nodeArity() > " + callingScope.closeCondition in callingScope]
       [/#if]
    [/#if]
[/#macro]

[#--  Boilerplate code to create the node variable --]
[#macro createNode treeNodeBehavior nodeVarName]
   [#var nodeName = NODE_PREFIX + currentProduction.name]
   [#if treeNodeBehavior?? && treeNodeBehavior.nodeName??]
      [#set nodeName = NODE_PREFIX + treeNodeBehavior.nodeName]
   [/#if]
   ${nodeName} ${nodeVarName} = null;
   if (buildTree) {
   [#if NODE_USES_PARSER]
        ${nodeVarName} = new ${nodeName}(this);
   [#else]
       ${nodeVarName} = new ${nodeName}();
   [/#if]
	    openNodeScope(${nodeVarName});
  }
[/#macro]


[#macro BuildExpansionCode expansion]
    [#var classname=expansion.simpleName]
    [#if classname = "CodeBlock"]
       ${expansion}
    [#elseif classname = "ExpansionSequence"]
       [@BuildCodeSequence expansion/]
    [#elseif classname = "NonTerminal"]
       [@BuildCodeNonTerminal expansion/]
    [#elseif expansion.isRegexp]
       [@BuildCodeRegexp expansion/]
    [#elseif classname = "TryBlock"]
       [@BuildCodeTryBlock expansion/]
    [#elseif classname = "AttemptBlock"]
       [@BuildCodeAttemptBlock expansion /]
    [#elseif classname = "ZeroOrOne"]
       [@BuildCodeZeroOrOne expansion/]
    [#elseif classname = "ZeroOrMore"]
       [@BuildCodeZeroOrMore expansion/]
    [#elseif classname = "OneOrMore"]
        [@BuildCodeOneOrMore expansion/]
    [#elseif classname = "ExpansionChoice"]
        [@BuildCodeChoice expansion/]
    [/#if]
[/#macro]

[#macro BuildCodeSequence expansion]
       [#list expansion.units as subexp]
           [@BuildCode subexp/]
       [/#list]        
[/#macro]

[#macro BuildCodeRegexp regexp]
       [#if regexp.LHS??]
          ${regexp.LHS} =  
       [/#if]
  [#if !grammar.options.faultTolerant]       
       consumeToken(TokenType.${regexp.label});
   [#else]
        consumeToken(TokenType.${regexp.label}, ${regexp.forced?string("true", "false")});
   [/#if]
[/#macro]

[#macro BuildCodeTryBlock tryblock]
   [#var nested=tryblock.nestedExpansion]
       try {
          [@BuildCode nested/]
       }
   [#list tryblock.catchBlocks as catchBlock]
       ${catchBlock}
   [/#list]
       ${tryblock.finallyBlock!}
[/#macro]


[#macro BuildCodeAttemptBlock attemptBlock]
   [#var nested=attemptBlock.nestedExpansion]
       try {
          stashParseState();
          [@BuildCode nested/]
          popParseState();
       }
       catch (ParseException e) {
           restoreStashedParseState();
           [#if attemptBlock.recoveryCode??]
              ${attemptBlock.recoveryCode}
           [/#if]
           [#if attemptBlock.recoveryExpansion??]
               [@BuildCode attemptBlock.recoveryExpansion /]
           [#else]
               if (false) throw new ParseException("Never happens!");
           [/#if]
       }
[/#macro]

[#macro BuildCodeNonTerminal nonterminal]
   pushOntoCallStack("${currentProduction.name}", "${nonterminal.inputSource}", ${nonterminal.beginLine}); 
   [#if grammar.options.faultTolerant && !nonterminal.production.forced]
     [@newVar type="boolean" init="currentNTForced"/]
    currentNTForced = ${nonterminal.forced?string("true", "false")};
   [/#if]
   try {
   [#if !nonterminal.LHS??]
       ${nonterminal.name}(${nonterminal.args!});
   [#else]
       ${nonterminal.LHS} = ${nonterminal.name}(${nonterminal.args!});
    [/#if]
    } finally {
        popCallStack();
    [#if grammar.options.faultTolerant && !nonterminal.production.forced]
        currentNTForced = boolean${newVarIndex};
    [/#if]
    }
[/#macro]


[#macro BuildCodeZeroOrOne zoo]
    [#var nestedExp=zoo.nestedExpansion]
    [#if zoo.alwaysSuccessful]
       [@BuildCode nestedExp/]
    [#else]
       [#var expansionCode]
       [#set expansionCode]
          [@BuildCode nestedExp/]
       [/#set]
       [@BuildBinaryChoiceCode zoo, expansionCode, null/]
    [/#if]
[/#macro]

[#var inFirstVarName = "", inFirstIndex =0]

[#macro BuildCodeOneOrMore oom]
   [#var nestedExp=oom.nestedExpansion, prevInFirstVarName = inFirstVarName/]
   [#if nestedExp.simpleName = "ExpansionChoice"]
     [#set inFirstVarName = "inFirst" + inFirstIndex, inFirstIndex = inFirstIndex +1 /]
     boolean ${inFirstVarName} = true; 
   [/#if]
   while (true) {
      [@BuildCode nestedExp/]
      [#if nestedExp.simpleName = "ExpansionChoice"]
         ${inFirstVarName} = false;
      [/#if]
      [@BuildBinaryChoiceCode oom, null, "break;"/]
   }
   [#set inFirstVarName = prevInFirstVarName /]
[/#macro]

[#macro BuildCodeZeroOrMore zom]
    [#var nestedExp=zom.nestedExpansion]
    while (true) {
       [@BuildBinaryChoiceCode zom, null, "break;"/] 
       [@BuildCode nestedExp/]
    }
[/#macro]

[[#macro BuildCodeChoice choice]
   [#-- TODO: This macro is too gnarly, need to break it up and simplify it  --]
   [#var actions=[], expansions = []]
   [#var defaultAction, inPhase1 = false, indentLevel = 0]
   // Not in phase 1
   [#set defaultAction]
      [#if choice.parent.simpleName = "ZeroOrOne" || choice.parent.simpleName = "ZeroOrMore"]
        // Do nothing by default
        ;                                  
      [#else]
        [#if choice.parent.simpleName = "OneOrMore"]if (${inFirstVarName}) { [/#if]
       pushOntoCallStack("${currentProduction.name}", "${choice.inputSource}", ${choice.beginLine});
       throw new ParseException(current_token.getNext(), ${choice.firstSetVarName}, callStack); 
        [#if choice.parent.simpleName = "OneOrMore"]}[/#if]
      [/#if]
   [/#set]
   [#list choice.choices as nested]
      [#var action]
      [#set action]
         [@BuildCode nested/]
      [/#set]
      [#if !nested.alwaysSuccessful]
         [#set expansions = expansions +[nested]]
         [#set actions = actions+[action]]
      [#else]
         [#set defaultAction = action]
         [#break]
      [/#if]
   [/#list]
   nextTokenType = nextTokenType();
   [#list expansions as expansion]
      [#if expansion.requiresScanAhead]
         [#if expansion_index = 0]
            [#set indentLevel = indentLevel+1]
            remainingLookahead = ${expansion.lookaheadAmount};
            currentLookaheadToken = current_token;
             if (
             [#if expansion.hasSemanticLookahead]
               (${expansion.semanticLookahead}) &&
            [/#if]
        [#elseif !inPhase1]
            } else {
            remainingLookahead = ${expansion.lookaheadAmount};
            currentLookaheadToken = current_token;
            [#set indentLevel = indentLevel+1]
              if (
             [#if expansion.hasSemanticLookahead]
               (${expansion.semanticLookahead}) &&
            [/#if]
         [#else]
            [#set indentLevel = indentLevel+1]
            else {
            [#set indentLevel = indentLevel +1]
            remainingLookahead = ${expansion.lookaheadAmount};
            currentLookaheadToken = current_token;
            if (
           [#if expansion.hasSemanticLookahead]
               (${expansion.semanticLookahead}) &&
           [/#if]
         [/#if]
                ${expansion.lookaheadExpansion.scanRoutineName}()
               ) { 
                   ${actions[expansion_index]}
         [#set inPhase1 = false]
       [#elseif expansion.lookaheadAmount = 1&& !expansion.hasSemanticLookahead &&!expansion.lookaheadExpansion.possiblyEmpty]
          [#if !inPhase1 && expansion_index >0]
                 } else {
          [/#if]
          [#if expansion_index !=0 && inPhase1]else[/#if]
               if ([@expansionCondition expansion /]) {
                  ${actions[expansion_index]}
               }
          [#set inPhase1 = true]
          // In phase1
    [#else]
          [#if expansion_index = 0]
             if (
             [#set indentLevel = indentLevel+1]
          [#elseif !inPhase1]
             } else if (
          [#else]
          else    if (
                [#set indentLevel = indentLevel+1]
          [/#if]
                  ${expansion.semanticLookahead!}) {
                      ${actions[expansion_index]}
          [#set inPhase1 = false]
          // Not in phase1 now
      [/#if]
   [/#list]
      [#if expansions?size = 0]
           ${defaultAction}
      [#elseif !inPhase1]
           } else {
             ${defaultAction}
      [#else]
          else {
                ${defaultAction}
          }
      [/#if]
      [#if indentLevel != 0]
      // Indent level is ${indentLevel}
         [#list 1..indentLevel as unused]
           }
         [/#list]
      [/#if]
[/#macro]

[#macro expansionCondition expansion]
  [#if expansion.firstSetTokenNames?size < 5] 
     [#list expansion.firstSetTokenNames as name]
       nextTokenType == TokenType.${name} 
       [#if name_has_next] || [/#if] 
     [/#list]
  [#else]
     ${expansion.firstSetVarName}.contains(nextTokenType()) 
  [/#if]
[/#macro]

[#macro BuildBinaryChoiceCode expansion action fallback]
   [#var emptyAction=!action?has_content]
   [#var emptyFallback=!action?has_content]
   [#var condition=expansion.semanticLookahead!]
   [#if expansion.requiresScanAhead]
      [#set condition]
        [#if expansion.semanticLookahead??]
          (${expansion.semanticLookahead}) &&
        [/#if]  
        [#if expansion.negated]![/#if]
        ${expansion.lookaheadExpansion.scanRoutineName}()
      [/#set]
     currentLookaheadToken = current_token;
     remainingLookahead = ${expansion.lookaheadAmount};
    [#elseif expansion.lookaheadAmount = 1&&!expansion.lookaheadExpansion.possiblyEmpty]
      [@newVar type="TokenType" init="nextTokenType()"/]
      [#set condition]
      [#if expansion.firstSetTokenNames?size>2]
      ${expansion.firstSetVarName}.contains(tokentype${newVarIndex})
      [#else]
      [#list expansion.firstSetTokenNames as tokenName]
             tokentype${newVarIndex} == TokenType.${tokenName} [#if tokenName_has_next]||[/#if]
      [/#list]
      [/#if]
     [/#set]
   [/#if]
  [@ifelse condition, action, fallback/]
[/#macro]

[#macro ifelse condition action1 action2]
   [#if condition?is_null || condition?trim?length = 0]
      ${action1!}
   [#else]
      [#if action1?has_content]
         if (${condition}) {
            ${action1}
         }
        [#if action2?has_content]
         else {
            ${action2}
         }
        [/#if]
      [#elseif action2?has_content]
         if (!(${condition})) {
            ${action2}
         }
      [/#if]
   [/#if] 
[/#macro]

[#var parserData=grammar.parserData]
[#var nodeNumbering = 0]
[#var NODE_USES_PARSER = grammar.options.nodeUsesParser]
[#var NODE_PREFIX = grammar.options.nodePrefix]
[#var currentProduction]

[#macro buildScanRoutine expansion count]
     private final boolean ${expansion.scanRoutineName}() {
     if (remainingLookahead <=0) return true;
      [@buildScanCode expansion, count/]
      return true;
    }
[/#macro]

[#macro buildScanCode expansion count]
  [#var classname=expansion.simpleName]
    [#if expansion.isRegexp]
      [@ScanCodeRegexp expansion/]
   [#elseif classname = "ExpansionSequence"]
      [@ScanCodeSequence expansion count/]
   [#elseif classname = "ZeroOrOne"]
      [@ScanCodeZeroOrOne expansion/]
   [#elseif classname = "ZeroOrMore"]
      [@ScanCodeZeroOrMore expansion/]
   [#elseif classname = "OneOrMore"]
      [@ScanCodeOneOrMore expansion/]
   [#elseif classname = "NonTerminal"]
      [@ScanCodeNonTerminal expansion/]
   [#elseif classname = "TryBlock" || classname="AttemptBlock"]
      [@buildScanCode expansion.nestedExpansion, count/]
   [#elseif classname = "ExpansionChoice"]
      [@ScanCodeChoice expansion /]
  [/#if]
[/#macro]

[#macro ScanCodeChoice choice]
   [@newVar "Token", "currentLookaheadToken"/]
   int remainingLookahead${newVarIndex} = remainingLookahead;
  [#list choice.choices as subseq]
	  [#if subseq.hasSemanticLookahead]
	    semanticLookahead = ${subseq.semanticLookahead};
	  [/#if]
	  if (
	  [#if subseq.hasSemanticLookahead]
	     !semanticLookahead || 
	  [/#if]
	  [#if subseq_has_next]
	     ![@InvokeScanRoutine subseq/]) {
	        currentLookaheadToken = token${newVarIndex};
	        remainingLookahead = remainingLookahead${newVarIndex};
	  [#else]
	     ![@InvokeScanRoutine subseq/]
	     ) 
	     return false;
	  [/#if]
  [/#list]
  [#var numBraces=choice.choices?size-1]
  [#if numBraces>0]
    [#list 1..numBraces as unused]
    }
    [/#list]
  [/#if]
[/#macro]

[#macro ScanCodeRegexp regexp]
     if (!scanToken(TokenType.${regexp.label})) return false;
[/#macro]

[#macro ScanCodeZeroOrOne zoo]
   [@newVar type="Token" init="currentLookaheadToken"/]
   if (![@InvokeScanRoutine zoo.nestedExpansion/]) 
      currentLookaheadToken = token${newVarIndex};
[/#macro]

[#macro ScanCodeZeroOrMore zom]
      while (true) {
         [@newVar type="Token" init="currentLookaheadToken"/]
         if (remainingLookahead == 0 || ![@InvokeScanRoutine zom.nestedExpansion/]) {
             currentLookaheadToken = token${newVarIndex};
             break;
         }
      }
[/#macro]

[#macro ScanCodeOneOrMore oom]
   if (![@InvokeScanRoutine oom.nestedExpansion/]) return false;
   while (true) {
       [@newVar type="Token" init="currentLookaheadToken"/]
       if (remainingLookahead == 0 || ![@InvokeScanRoutine oom.nestedExpansion/]) {
           currentLookaheadToken = token${newVarIndex};
           break;
       }
   }
[/#macro]

[#macro ScanCodeNonTerminal nt]
      if (![@InvokeScanRoutine nt.production.expansion/])
         return false;
[/#macro]

[#macro ScanCodeSequence sequence, count]
   [#list sequence.units as sub]
       [@buildScanCode sub, count/]
       [#set count = count - sub.minimumSize]
       [#if count<=0][#break][/#if]
   [/#list]
[/#macro]
    
[#macro InvokeScanRoutine expansion]
   [#if expansion.isRegexp]
       scanToken(TokenType.${expansion.label})
   [#else]
      ${expansion.scanRoutineName}()
   [/#if]
[/#macro]

[#var newVarIndex=0]
[#macro newVar type init=null]
   [#set newVarIndex = newVarIndex+1]
   ${type} ${type?lower_case}${newVarIndex}
   [#if init??]
      = ${init}
   [/#if]
   ;
[/#macro]   

[#macro comment]
[#var content, lines]
[#set content][#nested/][/#set]
[#set lines = content?split("\n")]
[#list lines as line]
//${line}
[/#list]
[/#macro]