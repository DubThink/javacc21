/* Generated by: ${generated_by}. ${filename} */
[#if grammar.parserPackage?has_content]
package ${grammar.parserPackage};
[/#if]

[#set classname = filename?substring(0, filename?length-5)]
[#set options = grammar.options]

import java.io.*;
import java.util.ArrayList;


public class ${classname} {

    private int tokenBegin;
    private int bufpos = -1;
    private WrappedReader wrappedReader;
    private int backupAmount;

    /** The buffersize parameter is only there for backward compatibility. It is currently ignored. */
    public ${classname}(Reader reader, int startline, int startcolumn, int buffersize) {
        this(reader, startline, startcolumn);
     }

    public ${classname}(Reader reader, int startline, int startcolumn) {
        this.wrappedReader = new WrappedReader(reader, startline, startcolumn);
    }

    public ${classname}(Reader reader) {
        this(reader, 1, 1, 4096);
    }


    private class LocationInfo {
         int ch=-1, line, column;
    }
    
    
    /**
     * sets the size of a tab for location reporting 
     * purposes, default value is 8.
     */
    public void setTabSize(int i) {wrappedReader.tabSize = i;}
    
    /**
     * returns the size of a tab for location reporting 
     * purposes, default value is 8.
     */
    public int getTabSize() {return wrappedReader.tabSize;}
    

   private ArrayList<LocationInfo> locationInfoBuffer = new ArrayList<>();
   
   private LocationInfo getLocationInfo(int pos) {
   
       while (pos >= locationInfoBuffer.size()) {
            locationInfoBuffer.add(null);
       }
       
       LocationInfo linfo = locationInfoBuffer.get(pos);
       
       if (linfo == null) {
           linfo = new LocationInfo();
           locationInfoBuffer.set(pos, linfo); 
       }
       
       return linfo;
   
   }
   
     int getBeginColumn() {
        return getLocationInfo(tokenBegin).column;
    }
    
    int getBeginLine() {
        return getLocationInfo(tokenBegin).line;
    }
   
        int getEndColumn() {
        return getLocationInfo(bufpos).column;
    }
    
        int getEndLine() {
        return getLocationInfo(bufpos).line;
    }
    
   
     public void backup(int amount) {
        backupAmount += amount;
        bufpos -= amount;
        if (bufpos  < 0) {
                throw new RuntimeException("Should never get here, I don't think!");
//              bufpos = 0;
        } 
    }


     public int readChar() {
        ++bufpos;
        if (backupAmount > 0) {
           --backupAmount;
           return getLocationInfo(bufpos).ch;         
        }
         int ch = wrappedReader.read();
         if (ch ==-1) {
           if (bufpos >0) --bufpos;
         }
        return ch;
    }

    public String getImage() {
          StringBuilder buf = new StringBuilder();
          for (int i =tokenBegin; i<= bufpos; i++) {
              buf.append((char) getLocationInfo(i).ch);
          }
          return buf.toString();
    }
    
    public char[] getSuffix(final int len) {
        char[] ret = new char[len];
         int startPos = bufpos - len +1;
         for (int i=0; i<len; i++) {
             ret[i] = (char) getLocationInfo(startPos+i).ch;
        }
        return ret;
    } 

  
    public int beginToken() {
         if (backupAmount > 0) {
              --backupAmount;
            ++bufpos;
            tokenBegin = bufpos;
            return getLocationInfo(bufpos).ch;
        }
        tokenBegin = 0;
        bufpos = -1;
        return readChar();
    }

    private class WrappedReader extends Reader {
    
        StringBuilder buf;
        Reader nestedReader;
        StringBuilder pushBackBuffer = new StringBuilder();
        int column = 0, line = -1, tabSize =8;
        private boolean prevCharIsCR, prevCharIsLF;
        private char lookaheadBuffer[] = new char[8192]; // Maybe this should be adjustable but 8K should be fine. Maybe revisit...
        private int lookaheadIndex, charsReadLast;
        
        
        WrappedReader(Reader nestedReader, int startline, int startcolumn) {
            this.nestedReader = nestedReader;
           line = startline;
           column = startcolumn - 1;
         }
         
        private int nextChar()  {

            if (lookaheadIndex<charsReadLast) {
                return lookaheadBuffer[lookaheadIndex++];
            }
            if (charsReadLast >0 && charsReadLast < 8192) {
                return -1;
            }
            try {
                charsReadLast = nestedReader.read(lookaheadBuffer, 0, 8192);
                if (charsReadLast <= 0) {
                     return -1;
                }
            } catch (IOException ioe) {
                 return -1; // Maybe handle this. REVISIT
            }
            lookaheadIndex = 0;
            return lookaheadBuffer[lookaheadIndex++];
        }

        public void close() throws IOException {
            nestedReader.close();
        }
        
        public int read()  {
        
             int ch;
             int pushBack = pushBackBuffer.length();
             if (pushBack >0) {
                 ch = pushBackBuffer.charAt(pushBack -1);
                 pushBackBuffer.setLength(pushBack -1);
                 updateLineColumn(ch);
                 return ch;
             }
             ch = nextChar();
             if (ch <0) {
                 return ch;
             }
//             if (ch == '\r' || ch == '\n') {
//                 ch = handleNewLine(ch);
//             }
             
[#if grammar.options.javaUnicodeEscape]             
             if (ch == '\\') {
                 ch = handleBackSlash();
             } else {
                 lastCharWasUnicodeEscape = true;
             }
[/#if]
             updateLineColumn(ch);
             return ch;
        }
        
        public int read(char[] cbuf, int off, int len) throws IOException {
              throw new UnsupportedOperationException();
        }
        
        void pushBack(int ch) {
           pushBackBuffer.append((char) ch);
        }
        
        int addedNewLines;
        StringBuilder pendingNewLines = new StringBuilder();
        
        private int handleNewLine(int ch) {
            int nextChar = nextChar();
            if (nextChar != '\n' && nextChar != '\r') {
                pushBack(nextChar);
            }
            return ch;
        }
        
        private int handleTab() {
             column--;
             column += (tabSize - (column % tabSize));
             return '\t';
        }
        
	    private void updateLineColumn(int c) {
           getLocationInfo(bufpos).ch = c;
	    
	        column++;
	        if (prevCharIsLF) {
	            prevCharIsLF = false;
	            ++line;
	            column = 1;
	        }
	        else if (prevCharIsCR) {
	            prevCharIsCR = false;
	            if (c == '\n') {
	                prevCharIsLF = true;
	            }
	            else {
	                ++line;
	                column = 1;
	            }
	        }
	        switch(c) {
	            case '\r' : 
	                prevCharIsCR = true;
	                break;
	            case '\n' : 
	                prevCharIsLF = true;
	                break;
	            default : break;
	        }
	        getLocationInfo(bufpos).line = line;
	        getLocationInfo(bufpos).column = column;
	    }

        
[#if grammar.options.javaUnicodeEscape]
        StringBuilder hexEscapeBuffer = new StringBuilder();
        boolean lastCharWasUnicodeEscape;
        
        private int handleBackSlash() {
               int nextChar = nextChar();
               if (nextChar != 'u') {
                   pushBack(nextChar);
                   lastCharWasUnicodeEscape = false;
                   return '\\';
               }
               hexEscapeBuffer = new StringBuilder("\\u");
               while (nextChar == 'u') {
                  nextChar = nextChar();
                  hexEscapeBuffer.append((char) nextChar);
               }
              // NB: There must be 4 chars after the u and 
              // they must be valid hex chars! REVISIT.
               for (int i =0;i<3;i++) {
                   hexEscapeBuffer.append((char) nextChar());
               }
               String hexChars = hexEscapeBuffer.substring(hexEscapeBuffer.length() -4);
               lastCharWasUnicodeEscape = true;
               return Integer.parseInt(hexChars, 16);
        }
[/#if]        
    }
}

