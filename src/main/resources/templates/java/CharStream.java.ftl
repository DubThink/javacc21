/* Generated by: ${generated_by}. ${filename} */
[#if grammar.parserPackage?has_content]
package ${grammar.parserPackage};
[/#if]

[#set classname = filename?substring(0, filename?length-5)]
[#set options = grammar.options]

import java.io.*;
import java.util.ArrayList;


public class ${classname} {

    private int tokenBegin;
    private int bufpos = -1;
    private WrappedReader wrappedReader;
    private int backupAmount;

    /** The buffersize parameter is only there for backward compatibility. It is currently ignored. */
    public ${classname}(Reader reader, int startline, int startcolumn, int buffersize) {
        this(reader, startline, startcolumn);
     }

    public ${classname}(Reader reader, int startline, int startcolumn) {
        this.wrappedReader = new WrappedReader(reader, startline, startcolumn);
    }

    public ${classname}(Reader reader) {
        this(reader, 1, 1);
    }


    /**
     * sets the size of a tab for location reporting 
     * purposes, default value is 8.
     */
    public void setTabSize(int i) {wrappedReader.tabSize = i;}
    
    /**
     * returns the size of a tab for location reporting 
     * purposes, default value is 8.
     */
    public int getTabSize() {return wrappedReader.tabSize;}
    

   
     public void backup(int amount) {
        backupAmount += amount;
        bufpos -= amount;
        if (bufpos  < 0) {
                throw new RuntimeException("Should never get here, I don't think!");
//              bufpos = 0;
        } 
    }


     public int readChar() {
        ++bufpos;
        if (backupAmount > 0) {
           --backupAmount;
           return wrappedReader.getCharAt(bufpos);
        }
         int ch = wrappedReader.read();
         if (ch ==-1) {
           if (bufpos >0) --bufpos;
         }
        return ch;
    }

    public String getImage() {
          StringBuilder buf = new StringBuilder();
          for (int i =tokenBegin; i<= bufpos; i++) {
              buf.append(wrappedReader.getCharAt(i));
          }
          return buf.toString();
    }
    
    String getSuffix(final int len) {
         StringBuilder buf = new StringBuilder();
         int startPos = bufpos - len +1;
         for (int i=0; i<len; i++) {
             buf.append(wrappedReader.getCharAt(startPos +i));
        }
        return buf.toString();
    } 

  
    public int beginToken() {
         if (backupAmount > 0) {
              --backupAmount;
            ++bufpos;
            tokenBegin = bufpos;
            return wrappedReader.getCharAt(bufpos);
        }
        tokenBegin = 0;
        bufpos = -1;
        return readChar();
    }
    
    
   
    int getBeginColumn() {
        return wrappedReader.getColumn(tokenBegin);
    }
    
    int getBeginLine() {
        return wrappedReader.getLine(tokenBegin);
    }
   
    int getEndColumn() {
        return wrappedReader.getColumn(bufpos);
    }
    
    int getEndLine() {
        return wrappedReader.getLine(bufpos);
    }
       

    private class WrappedReader {
    
        StringBuilder buf;
        Reader nestedReader;
        StringBuilder pushBackBuffer = new StringBuilder();
        int column = 0, line = -1, tabSize =8;
        private boolean prevCharIsCR, prevCharIsLF;
        private char lookaheadBuffer[] = new char[8192]; // Maybe this should be adjustable but 8K should be fine. Maybe revisit...
        private int lookaheadIndex, charsReadLast;
        
        
        WrappedReader(Reader nestedReader, int startline, int startcolumn) {
            this.nestedReader = nestedReader;
           line = startline;
           column = startcolumn - 1;
         }
         
        private int nextChar()  {

            if (lookaheadIndex<charsReadLast) {
                return lookaheadBuffer[lookaheadIndex++];
            }
            if (charsReadLast >0 && charsReadLast < 8192) {
                return -1;
            }
            try {
                charsReadLast = nestedReader.read(lookaheadBuffer, 0, 8192);
                if (charsReadLast <= 0) {
                     return -1;
                }
            } catch (IOException ioe) {
                 return -1; // Maybe handle this. REVISIT
            }
            lookaheadIndex = 0;
            return lookaheadBuffer[lookaheadIndex++];
        }

        int read()  {
             int ch;
             int pushBack = pushBackBuffer.length();
             if (pushBack >0) {
                 ch = pushBackBuffer.charAt(pushBack -1);
                 pushBackBuffer.setLength(pushBack -1);
                 updateLineColumn(ch);
                 return ch;
             }
             ch = nextChar();
             if (ch <0) {
                 return ch;
             }
//             if (ch == '\r' || ch == '\n') {
//                 ch = handleNewLine(ch);
//             }
             
[#if grammar.options.javaUnicodeEscape]             
             if (ch == '\\') {
                 ch = handleBackSlash();
             } else {
                 lastCharWasUnicodeEscape = true;
             }
[/#if]
             updateLineColumn(ch);
             return ch;
        }
        
        void pushBack(int ch) {
           pushBackBuffer.append((char) ch);
        }
        
        int addedNewLines;
        StringBuilder pendingNewLines = new StringBuilder();
        
        private int handleNewLine(int ch) {
            int nextChar = nextChar();
            if (nextChar != '\n' && nextChar != '\r') {
                pushBack(nextChar);
            }
            return ch;
        }
        
        private int handleTab() {
             column--;
             column += (tabSize - (column % tabSize));
             return '\t';
        }
        
	    private void updateLineColumn(int c) {
	        column++;
	        if (prevCharIsLF) {
	            prevCharIsLF = false;
	            ++line;
	            column = 1;
	        }
	        else if (prevCharIsCR) {
	            prevCharIsCR = false;
	            if (c == '\n') {
	                prevCharIsLF = true;
	            }
	            else {
	                ++line;
	                column = 1;
	            }
	        }
	        switch(c) {
	            case '\r' : 
	                prevCharIsCR = true;
	                break;
	            case '\n' : 
	                prevCharIsLF = true;
	                break;
	            default : break;
	        }
            setLocationInfo(bufpos, c, line, column);
	    }

        
[#if grammar.options.javaUnicodeEscape]
        StringBuilder hexEscapeBuffer = new StringBuilder();
        boolean lastCharWasUnicodeEscape;
        
        private int handleBackSlash() {
               int nextChar = nextChar();
               if (nextChar != 'u') {
                   pushBack(nextChar);
                   lastCharWasUnicodeEscape = false;
                   return '\\';
               }
               hexEscapeBuffer = new StringBuilder("\\u");
               while (nextChar == 'u') {
                  nextChar = nextChar();
                  hexEscapeBuffer.append((char) nextChar);
               }
              // NB: There must be 4 chars after the u and 
              // they must be valid hex chars! REVISIT.
               for (int i =0;i<3;i++) {
                   hexEscapeBuffer.append((char) nextChar());
               }
               String hexChars = hexEscapeBuffer.substring(hexEscapeBuffer.length() -4);
               lastCharWasUnicodeEscape = true;
               return Integer.parseInt(hexChars, 16);
        }
[/#if]

     private int[] locationInfoBuffer = new int[3072];
   
     int getLine(int pos) {
         return locationInfoBuffer[pos*3+1];
     }
     
     int getColumn(int pos) {
         return locationInfoBuffer[pos*3+2];
     }
     
     char getCharAt(int pos) {
         return (char) locationInfoBuffer[pos*3];
     }
     
     private void setLocationInfo(int pos, int ch, int line, int column) {
          pos *=3;
          if (pos >= locationInfoBuffer.length) {
              expandBuff();
          }
          locationInfoBuffer[pos++] = ch;
          locationInfoBuffer[pos++] = line;
          locationInfoBuffer[pos++] = column;
    }
    
     private void expandBuff() {
           int[] newBuf = new int[locationInfoBuffer.length*2];
           System.arraycopy(locationInfoBuffer, 0, newBuf, 0,  locationInfoBuffer.length);
           locationInfoBuffer = newBuf;
     }
     
    
  }
}

