/* Generated by: ${generated_by}. ${filename} */
[#if grammar.parserPackage?has_content]
package ${grammar.parserPackage};
[/#if]

[#if grammar.options.userCharStream || grammar.options.userDefinedLexer]
[#include "CharStreamInterface.java.ftl"]
[#else]
[#set classname = filename?substring(0, filename?length-5)]
[#set options = grammar.options]

import java.io.*;

[#if options.javaUnicodeEscape]
/**
 * A CharStream that handles unicode escape sequences
 * as in java source files
 */
[#else]
/**
 * A simple CharStream that has no special escaping.
 */
[/#if]

public class ${classname} {


    private class LocationInfo {
         char ch;     
         int bufferPosition, line, column;
    }
   private LocationInfo[] locationInfoBuffer;
   
   private LocationInfo getLocationInfo(int pos) {
       if (locationInfoBuffer[pos] == null) {
           locationInfoBuffer[pos] = new LocationInfo();
       }
       return locationInfoBuffer[pos];
   }

    private final int bufsize = 4096;
    private int available, tokenBegin;
    private int bufpos = -1;
    private int column = 0;
    private int line = 1;
    private boolean prevCharIsCR, prevCharIsLF;
    private Reader reader;
    
    private int maxNextCharInd, backupAmount, tabSize=8;
    
        
    /**
     * sets the size of a tab for location reporting 
     * purposes, default value is 8.
     */
    public void setTabSize(int i) {this.tabSize = i;}
    
    /**
     * returns the size of a tab for location reporting 
     * purposes, default value is 8.
     */
    public int getTabSize() {return tabSize;}
    
    private void updateLineColumn(char c) {
        column++;
        if (prevCharIsLF) {
            prevCharIsLF = false;
            ++line;
            column = 1;
        }
        else if (prevCharIsCR) {
            prevCharIsCR = false;
            if (c == '\n') {
                prevCharIsLF = true;
            }
            else {
                ++line;
                column = 1;
            }
        }
        switch(c) {
            case '\r' : 
                prevCharIsCR = true;
                break;
            case '\n' : 
                prevCharIsLF = true;
                break;
            case '\t' : 
                column--;
                column += (tabSize - (column % tabSize));
                break;
            default : break;
        }
        getLocationInfo(bufpos).line = line;
        getLocationInfo(bufpos).column = column;
    }
    
    /** Read a character. */
    public char readChar() throws IOException {
        if (backupAmount > 0) {
           --backupAmount;
           ++bufpos;
           if (bufpos == bufsize) {
               bufpos = 0;
           }
           return getLocationInfo(bufpos).ch;         
        }
[#if !options.javaUnicodeEscape]
        if (++bufpos >= maxNextCharInd) {
            fillBuff();
        }
        char c = getLocationInfo(bufpos).ch;
[#else]
        ++bufpos;

        char c;
        
          c = readByte();
          getLocationInfo(bufpos).ch = c;
          if (c == '\\') {

            updateLineColumn(c);
            int backSlashCnt = 1;

            for (;;) // Read all the backslashes
            {
                ++bufpos;
                try {
                    c = readByte();
                    getLocationInfo(bufpos).ch = c;
                    if (c != '\\') { 
                        updateLineColumn(c);
                        // found a non-backslash char.
                        if ((c == 'u') && ((backSlashCnt & 1) == 1)) {
                            if (--bufpos < 0)
                                bufpos = bufsize - 1;

                            break;
                        }

                        backup(backSlashCnt);
                        return '\\';
                    }
                } catch (IOException e) {
                    if (backSlashCnt > 1)
                        backup(backSlashCnt - 1);
                    return '\\';
                }
                updateLineColumn(c);
                backSlashCnt++;
            }

            // Here, we have seen an odd number of backslash's followed by a 'u'
            try {
                while ((c = readByte()) == 'u')
                    ++column;
                LocationInfo linfo = getLocationInfo(bufpos);
                linfo.ch = c = (char) (hexval(c) << 12
                        | hexval(readByte()) << 8 | hexval(readByte()) << 4 | hexval(readByte()));

                column += 4;
            } catch (IOException e) {
                throw new Error("Invalid escape character at line " + line
                        + " column " + column + ".");
            }

            if (backSlashCnt == 1) {
                return c;
            }
            else {
                backup(backSlashCnt - 1);
                return '\\';
            }
        }
[/#if]        
        updateLineColumn(c);
        return c;
    }
    
   
    /** Get token beginning column number. */
    int getBeginColumn() {
        return getLocationInfo(tokenBegin).column;
    }
    
    /** Get token beginning line number. */
    int getBeginLine() {
        return getLocationInfo(tokenBegin).line;
    }
   
    /** Get token end column number. */
    int getEndColumn() {
        return getLocationInfo(bufpos).column;
    }
    
    /** Get token end line number. */
    int getEndLine() {
        return getLocationInfo(bufpos).line;
    }
    
   
    /** Backup a number of characters. */
    public void backup(int amount) {
        backupAmount += amount;
        bufpos -= amount;
        if (bufpos  < 0) {
//              bufpos = 0;
            bufpos += bufsize;
        }
    }

    /** Constructor. */
    public ${classname}(Reader reader, int startline, int startcolumn, int buffersize) {
        this.reader = reader;
        line = startline;
        column = startcolumn - 1;
        available = buffersize;
        locationInfoBuffer = new LocationInfo[buffersize];
        
[#if options.javaUnicodeEscape]
        nextCharBuf = new char[4096];
[/#if]
     }

     /** Constructor. */
    public ${classname}(Reader reader, int startline, int startcolumn) {
        this(reader, startline, startcolumn, 4096);
    }

    /** Constructor. */
    public ${classname}(Reader reader) {
        this(reader, 1, 1, 4096);
    }
    
    /** Get token literal value. */
    public String getImage() {
//        String image;
        if (bufpos >= tokenBegin) { 
              StringBuilder buf = new StringBuilder();
              for (int i =tokenBegin; i<= bufpos; i++) {
                  buf.append(getLocationInfo(i).ch);
              }
              return buf.toString();
        }
        else { 
             StringBuilder buf = new StringBuilder();
             for (int i=tokenBegin; i<bufsize; i++) {
                  buf.append(getLocationInfo(i).ch);
             }
             for (int i=0; i<=bufpos; i++) {
                  buf.append(getLocationInfo(i).ch);
             }
             return buf.toString();
        }
    }
    
    /** Get the suffix. */
    public char[] getSuffix(final int len) {
        char[] ret = new char[len];
        if ((bufpos + 1) >= len) { 
             int startPos = bufpos - len +1;
             for (int i=0; i<len; i++) {
                 ret[i] = getLocationInfo(startPos+i).ch;
             }
        }
        else {
            int startPos = bufsize - (len-bufsize-1);
            int lengthToCopy = len - bufpos -1;
            for (int i=0; i<lengthToCopy; i++) {
                ret[i] = getLocationInfo(startPos+i).ch;
            }
            lengthToCopy = len - bufpos -1;
            int destPos = len-bufpos-1;
            for (int i=0; i<lengthToCopy; i++) {
                ret[destPos+i] = getLocationInfo(i).ch;
            }
            
        }
        return ret;
    } 

  
[#if grammar.options.javaUnicodeEscape]
  static int hexval(char c) {
    switch(c)
    {
       case '0' :
          return 0;
       case '1' :
          return 1;
       case '2' :
          return 2;
       case '3' :
          return 3;
       case '4' :
          return 4;
       case '5' :
          return 5;
       case '6' :
          return 6;
       case '7' :
          return 7;
       case '8' :
          return 8;
       case '9' :
          return 9;

       case 'a' :
       case 'A' :
          return 10;
       case 'b' :
       case 'B' :
          return 11;
       case 'c' :
       case 'C' :
          return 12;
       case 'd' :
       case 'D' :
          return 13;
       case 'e' :
       case 'E' :
          return 14;
       case 'f' :
       case 'F' :
          return 15;
    }
    throw new RuntimeException("Cannot parse escaped unicode char");// REVISIT, currently unhandled
  }

 
    private char readByte() throws IOException {
        if (++nextCharInd >= maxNextCharInd)
            fillBuff();

        return nextCharBuf[nextCharInd];
    }
    
    private void fillBuff() throws IOException {
        if (maxNextCharInd == 4096)
            maxNextCharInd = nextCharInd = 0;

        try {
            int charsRead =   reader.read(nextCharBuf, maxNextCharInd, 4096 - maxNextCharInd);
            if (charsRead == -1) {
                throw new IOException();
            } 
            maxNextCharInd += charsRead;
            return;
        } catch (IOException e) {
            if (bufpos != 0) {
                --bufpos;
                backup(0);
            } else {
                getLocationInfo(bufpos).line = line;
                getLocationInfo(bufpos).column = column;
            }
            throw e;
        }
    }
  
    public char beginToken() { 
        if (backupAmount > 0) {
            --backupAmount;

            if (++bufpos == bufsize)
                bufpos = 0;

            tokenBegin = bufpos;
            return getLocationInfo(bufpos).ch;
        }

        tokenBegin = 0;
        bufpos = -1;
        try {        
        	return readChar();
        } catch (IOException ioe) {
            return (char) -1;
        }
    }
    
    private char[] nextCharBuf;
    private int nextCharInd = -1;
[#else]
    private void fillBuff() throws IOException {
        if (maxNextCharInd == available) {
            if (available == bufsize) {
                 if (tokenBegin > 2048) {
                     bufpos = maxNextCharInd = 0;
                     available = tokenBegin;
                }
                else if (tokenBegin < 0) {
                    bufpos = maxNextCharInd = 0;
                }
            }
	        else if (available > tokenBegin) {
               available = bufsize; 
            }
            else if ((tokenBegin - available) >= 2048) {
                available = tokenBegin;
            }
        }
        try {
            int j = 0;
            int charsToRead = available - maxNextCharInd;
            for (j = 0; j< charsToRead; j++) {
                 int ch = reader.read();
                 if (ch ==-1) {
                     if (j==0) throw new IOException();
                     break;
                 }
                 getLocationInfo(maxNextCharInd + j).ch = (char) ch;
            }
            maxNextCharInd += j;
            return;
        }
        catch(IOException e) {
            --bufpos;
            backup(0);
            if (tokenBegin == -1) {
                tokenBegin = bufpos;
            }
            throw e;
        }
    }
    
    public char beginToken() {
        tokenBegin = -1;
        try {
	        char c = readChar();
	        tokenBegin = bufpos;
	        return c;
        } catch (IOException ioe) {
            return (char) -1;
        }
    }
[/#if]
   
}
[/#if]
