JAVA_UNICODE_ESCAPE;
SPECIAL_TOKENS_ARE_NODES;
PARSER_PACKAGE="org.parsers.csharp";
NODE_PACKAGE="org.parsers.csharp.tree";
DEFAULT_LEXICAL_STATE=CSHARP;
PRESERVE_LINE_ENDINGS=false;
TABS_TO_SPACES=8;

// The following Token productions are lifted straight from the Java grammar. Should REVISIT

UNPARSED :
  <WHITESPACE : (" "| "\t"| "\n"| "\r"| "\f")+> #Whitespace   
;

<IN_MULTI_LINE_COMMENT>
UNPARSED :
  <MULTI_LINE_COMMENT: "*/" > #Comment : CSHARP
;

MORE : 
  "//" : IN_SINGLE_LINE_COMMENT
  |
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
  |
  "/*" : IN_MULTI_LINE_COMMENT
;

<IN_SINGLE_LINE_COMMENT>
UNPARSED :
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > #Comment : CSHARP
;


<IN_FORMAL_COMMENT>
UNPARSED :
  <FORMAL_COMMENT: "*/" > #DocComment : CSHARP
;

INJECT DocComment : extends Comment;

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
  < ~[] >
;

TOKEN #Literal :
  < LONG_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])
      | <HEX_LITERAL> (["l","L"])
      | <OCTAL_LITERAL> (["l","L"])
      | <BINARY_LITERAL> (["l","L"])
  >
  |
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL>
      | <HEX_LITERAL>
      | <OCTAL_LITERAL>
      | <BINARY_LITERAL>
  >
  | 
  < #DECIMAL_LITERAL: ["0"-"9"]((["0"-"9","_"])*["0"-"9"])? >
  |
  < #HEX_LITERAL: "0" ["x","X"] <HEX_DIGITS> >
  |
  < #OCTAL_LITERAL: "0" ["0"-"7"]((["0"-"7","_"])*["0"-"7"])? >
  |
  < #BINARY_LITERAL: "0" ["b","B"] ["0","1"]((["0","1","_"])*["0","1"])? >
  |
  < FLOATING_POINT_LITERAL:
        <DECIMAL_FLOATING_POINT_LITERAL>
      | <HEXADECIMAL_FLOATING_POINT_LITERAL>
  >
  |
  < #DECIMAL_FLOATING_POINT_LITERAL:
        <DECIMAL_LITERAL> "." (<DECIMAL_LITERAL>)? (<DECIMAL_EXPONENT>)? (["f","F","d","D"])?
      | "." <DECIMAL_LITERAL> (<DECIMAL_EXPONENT>)? (["f","F","d","D"])?
      | <DECIMAL_LITERAL> <DECIMAL_EXPONENT> (["f","F","d","D"])?
      | <DECIMAL_LITERAL> (<DECIMAL_EXPONENT>)? ["f","F","d","D"]
  >
  |
  < #DECIMAL_EXPONENT: ["e","E"] (["+","-"])? (<DECIMAL_LITERAL>)+ >
  |
  < #HEXADECIMAL_FLOATING_POINT_LITERAL:
        <HEX_LITERAL> (".")? <HEXADECIMAL_EXPONENT> (["f","F","d","D"])?
      | "0" ["x","X"] (<HEX_DIGITS>)? "." <HEX_DIGITS> <HEXADECIMAL_EXPONENT> (["f","F","d","D"])?
  >
  |
  < #HEXADECIMAL_EXPONENT: ["p","P"] (["+","-"])? <DECIMAL_LITERAL> >
  |
  < #HEX_DIGITS: ["0"-"9","a"-"f","A"-"F"]((["0"-"9","a"-"f","A"-"F","_"])*["0"-"9","a"-"f","A"-"F"])? >
  |
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
  |
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
;

TOKEN #Delimiter :
  < LPAREN: "(" > 
| < RPAREN: ")" >
| < LBRACE: "{" > 
| < RBRACE: "}" > 
| < LBRACKET: "[" > 
| < RBRACKET: "]" > 
| < SEMICOLON: ";" > 
| < COMMA: "," > 
| < DOT: "." > 
| < ASSIGN: "=" > 
| < DOUBLE_COLON: "::" > 
| < VAR_ARGS: "..." > 
| < AT : "@"> 
;

TOKEN #Operator : 
 < GT: ">" > 
| < LT: "<" > 
| < BANG: "!" > 
| < TILDE: "~" > 
| < HOOK: "?" > 
| < COLON: ":" > 
| < EQ: "==" > 
| < LE: "<=" > 
| < GE: ">=" > 
| < NE: "!=" > 
| < SC_OR: "||" > 
| < SC_AND: "&&" > 
| < INCR: "++" > 
| < DECR: "--" > 
| < PLUS: "+" > 
| < MINUS: "-" > 
| < STAR: "*" > 
| < SLASH: "/" > 
| < BIT_AND: "&" > 
| < BIT_OR: "|" > 
| < XOR: "^" > 
| < REM: "%" > 
| < LSHIFT: "<<" > 
| < PLUSASSIGN: "+=" > 
| < MINUSASSIGN: "-=" > 
| < STARASSIGN: "*=" > 
| < SLASHASSIGN: "/=" > 
| < ANDASSIGN: "&=" > 
| < ORASSIGN: "|=" > 
| < XORASSIGN: "^=" > 
| < REMASSIGN: "%=" > 
| < LEFT_SHIFT_ASSIGN: "<<=" > 
|  < RIGHT_SHIFT: ">>" > 
| < RIGHT_SHIFT_ASSIGN: ">>=" > 
| < LAMBDA : "=>"> 
;

// C# Keywords

TOKEN #KeyWord : 
   <ABSTRACT : "abstract" > 
   | < AS : "as" > 
   | < BASE : "base" > 
   | < BOOL : "bool" > 
   | < BREAK : "break" >
   | < BYTE : "byte" > 
   |  <CASE : "case" > 
   | < CATCH : "catch" > 
   | < CHAR : "char" > 
   | < CHECKED : "checked" > 
   | < CLASS : "class" > 
   | < CONST : "const" > 
   | < CONTINUE : "continue" > 
   | < DECIMAL : "decimal" > 
   | < DEFAULT : "default" > 
   | < DELEGATE : "delegate" > 
   | < DO : "do" > 
   | < DOUBLE : "double" > 
   | < ELSE : "else" > 
   | < ENUM : "enum" > 
   | < EVENT : "equals" > 
   | < EXPLICIT : "explicit" > 
   | < EXTERN : "extern" > 
   | < FALSE : "false" > 
   | < FINALLY : "finally" > 
   | < FIXED : "fixed" > 
   | < FLOAT : "float" > 
   | < FOR : "for" > 
   | < FOREACH : "foreach" > 
   | < GOTO : "goto" > 
   | < IF : "if" > 
   | < IMPLICIT : "implicit" > 
   | < IN : "in" > 
   | < INT : "int" > 
   | < INTERFACE : "interface" > 
   | < INTERNAL : "internal" > 
   | < IS : "is">
   | < LOCK : "lock" >
   | < LONG : "long" >
   | < NAMESPACE : "namespace" >
   | < NEW : "new" >
   | < NULL : "null" >
   | < OBJECT : "object" >
   | < OPERATOR : "operator" >
   | < OUT : "out" >
   | < OVERRIDE : "override" >
   | < PARAMS : "params">
   | < PRIVATE : "private" > 
   | < PROTECTED : "protected" > 
   | < PUBLIC : "public" > 
   | < READONLY : "readonly" > 
   | < REF : "ref" > 
   | < RETURN : "return" > 
   | < SBYTE : "sbyte" > 
   | < SEALED : "sealed" > 
   | < SHORT : "short" > 
   | < SIZEOF : "sizeof" > 
   | < STACKALLOC : "stackalloc" > 
   | < STATIC : "static" > 
   | < STRING : "string" > 
   | < STRUCT : "struct" > 
   | < SWITCH : "switch" > 
   | < THIS : "this" > 
   | < THROW : "throw" > 
   | < TRUE : "true" >
   | < TRY : "try" >
   | < TYPEOF : "typeof" >
   | < UINT : "uint" >
   | < ULONG : "ulong" >
   | < UNCHECKED : "unchecked" >
   | < UNSAFE : "unsafe" >
   | < USHORT : "ushort" > 
   | < USING : "using" > 
   | < VIRTUAL : "virtual" > 
   | < VOID : "void" >
   | < VOLATILE : "volatile" > 
   | < WHILE : "while" > 
;


CompilationUnit :
   (ExternAliasDirective)*
   (UsingDirective)*
   (GlobalAttributeSection)*
   (
      NamespaceDeclaration
      |
      TypeDeclaration
    )* 
   <EOF>
;

ExternAliasDirective :
   "extern" "alias" <IDENTIFIER> ";"
;

UsingDirective :
    UsingStaticDirective
    |
    UsingAliasDirective
    |
    UsingNamespaceDirective
;    

UsingStaticDirective : 
    "using" "static" =>|| Name ";"
; 

UsingAliasDirective :
   "using" <IDENTIFIER> "=" =>|| Name ";"
;

UsingNamespaceDirective :
    "using" Name ";" =>||
;

GlobalAttributeSection :
   "["  ("assembly" | "module") ":" AttributeList [","] "]"
;

AttributeSection :
   "["
   ("field"|"event"|"method"|"param"|"property"|"return"|"type")
   ":"
   AttributeList
   [","]
   "]"
;

AttributeList :
     Attribute ("," Attribute)*
;

Attribute :
   Name
   [AttributeArguments]
;

AttributeArguments :
    "(" 
    [
       SCAN ~(<IDENTIFIER>"=")
       => Expression()
       (
          ","
          Expression()
       )*
    ]
    [
       SCAN <IDENTIFIER>"="
       => NamedArgument
       (
          "," NamedArgument
       )*
    ]
    ")"  
;

NamedArgument :
    <IDENTIFIER> "=" Expression
;


/** Name of a Type or a Namespace */
Name :
   SCAN <IDENTIFIER> "::"
   => QualifiedAliasMember()
   |
   <IDENTIFIER>[TypeArgumentList()]
   ("." <IDENTIFIER> [TypeArgumentList()])*
;

QualifiedAliasMember :
   <IDENTIFIER> "::" <IDENTIFIER>
   [TypeArgumentList]
;

TypeArgumentList() :
   "<"
   [
      Type
      ("," Type)* 
   ]
   ">"
;

Expression :  Name; // TODO!

NamespaceDeclaration() :
   "namespace"  QualifiedIdentifier NamespaceBody
;

QualifiedIdentifier :
    <IDENTIFIER> ("." <IDENTIFIER>)*
;

NamespaceBody :
   "{"
       (ExternAliasDirective)* (UsingDirective)* 
       (
          NamespaceDeclaration
          |
          TypeDeclaration
       )
   "}"
;

TypeDeclaration :
   (AttributeSection)*
   ("new"|"public"|"protected"|"internal"|"private"|"abstract"|"sealed"|"static"|"unsafe")*
   ["partial"]
   (
     ClassDeclaration
     |
     StructDeclaration
     |
     InterfaceDeclaration
     |
     EnumDeclaration
     |
     DelegateDeclaration
   )
;

ClassDeclaration :
  "class"
   <IDENTIFIER>
  [TypeParameterList]
  [":" (Name | "object" | "dynamic" | "string") ("," Name)*]
  (TypeParameterConstraintsClause)*
  ClassBody
  [";"]
;

StructDeclaration :
    "struct" 
    <IDENTIFIER>
    [":" Name ("," Name)*]
    (TypeParameterConstraintsClause)*
   StructBody
   [";"] 
;

InterfaceDeclaration :
   "interface"
   <IDENTIFIER>
   [TypeParameterList]
   [Name ("," Name)*]
   (TypeParameterConstraintsClause)*
   InterfaceBody
   [";"]
;

EnumDeclaration : 
   "enum" 
   <IDENTIFIER>
   [":" ("sbyte"|"byte"|"short"|"ushort"|"int"|"uint"|"long"|"ulong"|"char")]
   EnumBody
   [";"]
;

DelegateDeclaration :
  "delegate" 
  Type
  <IDENTIFIER>
  [TypeParameterList]
  "("
//  [FormalParameterList] //TODO
  ")"
  (TypeParameterConstraintsClause)*
;

TypeParameterConstraintsClause :
  "where" <IDENTIFIER> ":" (Name | "class" | "struct") ["," Name]
;

ClassBody :
   "{"
//   (ClassMemberDeclaration)* //TODO      
   "}"
;

InterfaceBody :
   "{"
//  (InterfaceMemberDeclaration)* //TODO
   "}"
;

StructBody :
   "{"
//      (StructMemberDeclaration())* //TODO
   "}"
;

TypeParameterList :
   "<"
   (AttributeSection)*
   ["in"|"out"] // Only with interfaces 
   Name
   ("," (AttributeSection)* Name)*    
   ">"
;

EnumBody :
   "{"
// TODO   
//   [
//      EnumMemberDeclaration
//      ("," EnumMemberDeclaration)*
//   ]
   "}"
;

Type :
    => "void" "*"
    |
    "void" // REVISIT, lone void is only valid in a return type
    |
    (
       (
        "object"|"dynamic"|"string"|"decimal"|"sbyte"|"byte"|"short"|"ushort"|"int"|"uint"|"long"|"ulong"|"char"|"float"|"double"|"bool"
        |
        Name() ["?"]
      )
      [ "[" (",")* "]" ]
      ["*"]
   )
;

// Just using the Java definition of an identifier for now.
// I'm sure it's not quite correct!
INCLUDE ("../java/JavaIdentifierDef.javacc")

TOKEN :
  < IDENTIFIER: <LETTER> (<PART_LETTER>)* > #Identifier
;