/*
 * Unfinished work on a Python grammar. I am working from the information in
 * following two web pages:
 * https://docs.python.org/3/reference/grammar.html
 * https://docs.python.org/3/reference/lexical_analysis.html#indentation
 * This is Python 3.9.5, which I presume is the latest spec. 
 * (I do not anticipate supporting any older versions of the language.)
 */

PARSER_PACKAGE = org.parsers.python;
NODE_PACKAGE = org.parsers.python.ast;
DEFAULT_LEXICAL_STATE = PYTHON;
TABS_TO_SPACES=8;
ENSURE_FINAL_EOL;
PRESERVE_LINE_ENDINGS=false;
//DEBUG_LEXER;
//DEBUG_PARSER;

INCLUDE "PythonLexer.javacc" 

PythonFile : (Statement)* <EOF> ;

Number#void : <HEXNUMBER> | <BINNUMBER> | <OCTNUMBER> | <DECNUMBER> | <FLOAT> | <COMPLEX> ;

Strings : (<STRING_LITERAL>)+ ;

AtomicExpression : 
    <NAME> 
    | 
    Number 
    | 
    Strings
    | 
    "True" 
    | 
    "False" 
    | 
    "None" 
    | 
    "__peg_parser__" 
    |
    (Tuple | GenExp | Group)
    |
    (ListComp | PyList)
    |
    (SetComp | PyDict | PySet | DictComp)
    |
    "..."
;

Slice :
    [Expression] ":" =>|| [Expression] [":" [Expression]]
    |
    Expression
;

Slices : Slice ("," Slice)* [","] ;

Statement : SimpleStatement | CompoundStatement ;

SimpleStatement#(>2) : SmallStatement (";" SmallStatement)* <NEWLINE> ; 
           
SmallStatement : 
   Assignment
   |
   StarExpressions
   |
   ReturnStatement
   |
   ImportStatement 
   |
   GlobalStatement
   |
   NonlocalStatement
   |
   "break"
   |
   "continue"
   |
   "pass"
   |
   DelStatement
   |
   AssertStatement
   |
   RaiseStatement
   |
   YieldStatement
;

CompoundStatement :
    FunctionDefinition
    |
    IfStatement
    |
    ClassDefinition
    |
    WhileStatement
    |
    ForStatement
    |
    TryStatement
;    

ReturnStatement : "return" [StarExpressions] ;

GlobalStatement : "global" <NAME> ("," <NAME>)* ;

NonlocalStatement : "nonlocal" <NAME> ("," <NAME>)* ;

AssertStatement : "assert" Expression ("," Expression)* ;

RaiseStatement : "raise" [ Expression ["from" Expression ] ];

Block :
    SimpleStatement
    |
    <NEWLINE><INDENT>(Statement)+<DEDENT>
;    

ElseBlock : "else" ":" Block ;

ExceptBlock : "except" [ Expression ["as" <NAME>] ] ":" Block ;

IfStatement : 
    "if" NamedExpression ":" Block 
     ("elif" NamedExpression ":" Block)* 
     ["else" NamedExpression ":" Block]
;     

FinallyBlock : "finally" ":" Block ;

WhileStatement : "while" NamedExpression ":" Block [ElseBlock] ;

ForStatement : 
   ["async"] "for" =>|| 
   StarTargets "in" StarExpressions ":"
   Block [ElseBlock]
;

TryStatement : 
   "try" ":" Block 
   (
       FinallyBlock
       | 
       ((ExceptBlock)+ [ElseBlock] [FinallyBlock])
   )
;

DelStatement : "del" TargetPrimary ("," TargetPrimary)* [","] ; 

NamedExpression : [ => <NAME> ":=" ] Expression ;

DottedName : <NAME> (=> "." <NAME>)* ;

ImportStatement : ImportName | ImportFrom1 | ImportFrom2 ;

ImportName#void : "import" DottedName ("," DottedName)* ;

ImportFrom1#void : "from" ("." | "...")* DottedName =>|| "import"  ImportFromTargets ;

ImportFrom2#void : "from" ("." | "...")+ "import" =>|| ImportFromTargets ; 

ImportFromTargets : 
   "*"
   |
   <NAME> ["as" <NAME>] ("," <NAME> ["as" <NAME>])* 
   |
   "(" <NAME> ["as" <NAME>] ("," <NAME> ["as" <NAME>])* [","] ")"
;

StarNamedExpression : 
     "*" BitwiseOr
     |
     NamedExpression 
;

StarExpression :
    "*" BitwiseOr
    |
    Expression
;

StarExpressions : StarExpression ("," StarExpression)* [","] ;

StarNamedExpressions : StarNamedExpression ("," StarNamedExpression)* [","] ;

BitwiseOr : BitwiseXor ("|" BitwiseXor)* ;

BitwiseXor : BitwiseAnd ("^" BitwiseAnd)* ;

BitwiseAnd : ShiftExpression ("&" ShiftExpression)* ;

ShiftExpression : Sum (("<<" | ">>") Sum)* ;

Sum : Term (("+"|"-") Term)* ;

Term : Factor (("*"|"/"|"//"|"%"|"@") Factor)* ;

Factor : Power (("+"|"-"|"~") Power)* ;

Power : AwaitPrimary ["**" Factor] ;

Tuple : 
   SCAN "(" StarNamedExpression "," =>
    "(" [StarNamedExpression "," [StarNamedExpressions]] ")" 
;

Group : "(" (YieldExpression | NamedExpression) ")" ;

AwaitPrimary : ["await"] PrimaryExpression ;

PrimaryExpression : AtomicExpression (PrimarySuffix)* ;

PrimarySuffix :
    "." <NAME> 
    |
    GenExp
    |
    "(" [ Args [","] ] ")"
    |
    "[" Slices "]"
;


YieldExpression : 
    "yield" "from" =>|| Expression 
    |
    "yield" [StarExpressions]
;    

YieldStatement# : YieldExpression ;

AnnotatedRhs : YieldExpression | StarExpressions ;

Decorators : "@" NamedExpression <NEWLINE> ;

Annotation : ":" Expression ;

Default : "=" Expression ;

InvocationArguments : "(" [Args] ")" ;

Args : // This is a lot looser than the official grammar, but for now...
   (
       <NAME> (":="|"=") =>|| Expression
       |
       ["*" | "**"] Expression
   )
   (
       ","
       (
          <NAME> (":="|"=") =>|| Expression
          |
          ["*" | "**"] Expression
       )
   )*
   [","] 
;

KeywordArgs : 
     KeywordOrStarred ("," KeywordOrStarred)* ["," KeywordOrDoubleStarred ("," KeywordOrDoubleStarred)*] 
     |
     KeywordOrDoubleStarred ("," KeywordOrDoubleStarred)* 
;


KeywordOrStarred : ((<NAME> "=") | "*") Expression;

KeywordOrDoubleStarred : ((<NAME> "=") | "**") Expression;

KeyValuePair : Expression ":" Expression ;

DoubleStarredKeyValuePair : 
    "*" BitwiseOr
    |
    KeyValuePair
;

DoubleStarredKeyValuePairs : DoubleStarredKeyValuePair ("," DoubleStarredKeyValuePair)* [","] ;

PyDict : "{" [DoubleStarredKeyValuePairs] "}" ;

DictComp : "{" KeyValuePair (ForIfClause)+ "}" ;

PySet : "{" StarNamedExpressions "}" ;

SetComp : "{" NamedExpression =>|+2 (ForIfClause)+ "}" ;

ClassDefinition :
    [Decorators] "class" =>||
    <NAME> [InvocationArguments] 
    ":"
    Block
;

FunctionDefinition :
    [Decorators]
    ["async"]
    "def" =>||
    <NAME>
    "("
    Parameters
    ")"
    ["->" Expression]
    ":" Block
;

LambdaDefinition : "lambda" Parameters ":" Expression ;

/*
 * Expression grammar follows
 */

Expression : Disjunction ["if" Disjunction "else" Expression] | LambdaDefinition ; 

Disjunction : Conjunction ("or" Conjunction)* ;

Conjunction : Inversion ("and" Inversion)* ;

Inversion : ("not")* Comparison ;

Comparison : BitwiseOr (ComparisonOperator BitwiseOr)* ;

ComparisonOperator#void :
   "<" | ">" | "==" | ">=" | "<=" | "!=" 
   | 
   ["not"] "in" 
   |
   "is" ["not"]
;


StarTarget : ["*"] TargetPrimary ;

StarTargets : StarTarget ("," StarTarget)* ;

ForIfClause : ["async"] "for" StarTargets "in" Disjunction ("if" Disjunction)* ;

GenExp : "(" NamedExpression =>|+2 (ForIfClause)+ ")" ;

PyList : "[" [StarNamedExpressions] "]" ;

ListComp : "[" NamedExpression =>|+2 (ForIfClause)+ "]" ;

StarEtc :
   KeyWords
   |
   "*" "," =>|| ParamMaybeDefault ("," ParamMaybeDefault)* [KeyWords]
   |
   "*" <NAME> [":" Expression] ("," ParamMaybeDefault)* [KeyWords]
;

ParamMaybeDefault : <NAME> [":" Expression] ["=" Expression] ;

KeyWords :
   "**" <NAME> 
   [ 
       // This annotation is apparently disallowed in a lambda, but we'll deal with these details later.
       ":" Expression
   ]
;

INJECT PARSER_CLASS : {private boolean firstParam;}

Parameters :
    {firstParam = true;}#
    (<NAME> [":" Expression] [SCAN {firstParam}# "/" => "/"] {firstParam = false;}#)* 
    ("," <NAME> [":" Expression] ["=" Expression] [SCAN 1 {firstParam}# => "/"] {firstParam = false;})* 
    [StarEtc]
;

TargetPrimary :
   AtomicExpression
   [
       "." <NAME>
       |
       "[" Slices "]"
       |
       GenExp
       |
       InvocationArguments
   ]
;

DeleteTarget :
   TargetPrimary // Can I get away with this? 
;

AssignOp#void :
    "+=" | "-=" | "*=" | "@=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" 
    | ">>=" | "**=" | "//=" 
;

SimpleAssignTarget :
   TargetPrimary
   |
   "(" SimpleAssignTarget ")"
;

Assignment :
 SCAN (SimpleAssignTarget (":" | AssignOp)) | (StarTargets "=") =>
 (
  SimpleAssignTarget ":" =>|| Expression ["=" AnnotatedRhs]
  |
  SimpleAssignTarget AssignOp =>|| (YieldExpression | StarExpressions)
  |
  (=>StarTargets "=")+ =>|| (YieldExpression | StarExpressions)
 )
;